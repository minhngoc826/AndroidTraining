1. DevOps for Freshers
	1.0. Overview	
		- Envr:
			+ Development
			+ Staging
			+ UAT
			+ Sandbox
			
			+ Production
			
		- DevOps:
			+ Tại sao dùng công cụ/công nghệ này: cty có ai biết tools ngoài tôi k? có khả năng training đc cho ng khác về tools đó k? chứ ko phải vì nó xịn mà tôi dùng
			+ 
			
		- Laptop: 16GB Ram, 80GB HDD
		
		- Contents:
			+ 1. Linux			
			+ 2. Git			
			+ 3. CI/CD: 		tối ưu quy trình làm việc, gia tăng giá trị sp, tiết kiệm  trực tiếp tài nguyên cty -> 1 click là triển khai dự án
			+ 4. Docker:		docker hóa dự án / docker file	
			+ 5. Jenkins:		tools for CI/CD	
			+ 6. Monitoring:	tự động cảnh báo khi có lỗi
			
	1.1. Linux
		+ Ưu điểm:
			- tối ưu hs, tiết kiệm chi phí:		phù hợp hầu hết phần cứng của máy tính cá nhân & server, no GUI nên hiệu suất tốt hơn win, 
			- ổn định, bảo mật:					vòng đời os lâu, open source, qly truy cập mạnh & ngăn chặn truy cập trái phép
			- knang kiểm soát và linh hoạt: 	open source -> tùy chỉnh mọi thứ & toàn quyền, nhiều loại os -> lựa chọn phù hợp
			- pt & cập nhật:					cộng đồng pt lớn, cập nhật thường xuyên
			- tương thích đa nền tảng:			triển khai đc nhiều loại dự án với nguồn tài nguyên hợp lý
			- cộng đồng phát triển lớn:			cộng đồng chuyên tech
			
		+ Install Ubuntu server:
			- VMWare Network:
				+ Bridge:		các thiết bị khác sử dụng chung mạng sẽ truy cập trực tiếp đc đến web trên máy ảo (điện thoại, laptop khác, ... ~ mạng LAN nội bộ: 192.168.0/1.x) 	-> nên dùng với PC
				+ NAT:			chỉ truy cập đến web trên máy ảo từ thiết bị khởi tạo																								-> nên dùng với laptop
				
			- IP máy ảo: DHCPv4 ~ 192.168.1.1/24
				+ Nên set IP tĩnh, để khi tắt máy ảo và bật lại thì IP ko thay đổi
				+ sudo -i -> 
				+ nano /etc/netplan/xx_installer-config.yaml -> 
					- edit: 	dhcpv4: 		false
					- add: 		addresses: 	[192.168.1.110/24]
								gateway4:	192.168.1.1				~ Gateway IP của NAT -> VMWare settings
								nameservers:
								  addresses: [8.8.8.8,8.8.4.4]
				+ netplan apply
				+ ip add		-> check ip
				
				+ Virtual Box: 
					- NAT:			10.0.2.0/24
						+ enp0s3
						+ dhcpv4: 	10.0.2.15/24
					- Host only:	192.168.56.1/24
						+ enp0s8
						+ 
					- Bridge:
						+ 
						+ 
			
			- 
		
		+ Folders tree:
			- /: (root) contains subfolders below
				+ bin / boot / dev / etc / lib / media / mnt / opt / sbin / srv / 
				+ root: 
				+ home:	ngocnm / quanvd / ...
				+ usr:	bin / include / lib / sbin
				+ var:	cache / log / tmp / spool
				+ ...
		
		+ Commands:
			- Crt + C: exit
			
			- pwd: 		đang ở folder nào
			- whoami:	đăng nhập với user nào
			- cd folder / cd .. / cd ...
			- ls / ls folder / ls folder +  tab / ls -l / ls -a (show hidden) / ls -t (sort by time)
			- mkdir folder / mkdir -p folder/subfolder/subsub
			- touch filePath: tạo file
			- cat filePath: xem nội dung file
			- rm filePath / rm -r folder / rm -rf file/folder
			- cp -r folderPath destPath / cp filePath destPath
			- mv folder/file destPath
			- echo content / echo content > filePath: in nội dung - ghi đè / echo content >> filePath: append
			- history / clear / exit
			- tail -n [num] filePath > newFilePath: xem nội dung n dòng của file / tail -f filePath: xem content file real time
			
			- sudo: + command = chạy command với quyền root nên cần pass
				- sudo - i: sau lệnh này chạy tất cả command với quyền root
				
			- apt install/remove package -y: cài package ko cần xác nhận yes
			
			- Ram/Cpu usage:
				+ free -m	: ram usage
				+ df -h / 	: cpu usage
				+ top		: task manager
				
			- Server:
				+ sudo hostnamectl set-hostname newName
				+ sudo reboot
				
			- Netstat: netstat -tlpun
				+ -t: show tcp connection port
				+ -l: show port open & listen to accept connection
				+ -p: show process/program of connection
				+ -u: show udp connection
				+ -n: show ip & port dang so instead domain
			
			- Process: pf -ef
				+ ps -ef| grep shoeshop				(ps -ef: output của câu trước là input của câu sau;		grep xxx: tìm kiếm)
			
			- Internet:
				+ ping 8.8.8.8	 				= ping google.com
				+ telnet IP port				check connect to other server
				+ traceroute -T -p port IP	 	check port open or not (-T = tcp connection, -p = port)
		
		+ Vim editor:
			- vi filePath: mở file để edit, chưa có file thì tự tạo file mới
			- I: insert
				+ esc:	Command mode
				+ :x: 	exit & save
				+ :q!:	exit & not save
			- Command mode:
				+ dd: delete line
				+ U: = ctr + Z
				+ yy: copy line
				+ p: paste
				+ / + key: search
			
		
		+ Quyền truy cập: cần quyền root trước
			- User: 
				+ root user: 	superuser, rw all file, manage account, group, owner ~ sudo command
				+ system user:	created by the operating system during installation for running system processes and services -> used to run non-interactive or background processes
				+ regular user:	standard users, only rw files in home/user, can’t access other users’ files or system files without appropriate permissions.
				
				+ useradd:	add user only
				+ adduser: 	add user kèm create passwd, home/user folder, user info ... --> tạo xong ssh đc luôn
				+ su user:	switch user
				+ deluser user:		xóa user
				+ vi /etc/passwd:	xem thông tin user
				
			- Group: khi tạo 1 user mới thì tự động tạo 1 group mới cùng tên với user và add user vào group đó
				+ groupadd/delgroup=groupdell groupName:			
				+ usermod -aG groupName userName:		(-a = append, -G= liệt kê ds group của user, nếu bỏ -G thì xóa user khỏi các group đã add trước đó)
				+ groups userName:						kiểm tra list group của user
				+ deluser userName groupName:			xóa user khỏi group
				+ getent group/passwd/userName:			list group/passwd/userName
				
			- passwd: userName : passwd : userId : groupId : comment/description/userInfo : homeDirectory : shell
				
			- Owner permission: chown
				+ chủ sở hữu:		u
				+ nhóm sở hữu:		g
				+ nhóm user khác: 	o
				+ all:				a
				
				+ ls -l:	xem full folder/file infor:  
				+ chown -R owner:groupOwner folder/file		(-R: thay đổi folder cha thì thay đổi luôn file/folder con, nếu ko thì chỉ thay đổi folder cha)
				
			- Access permission: chmode, (quyền tối thiểu để tác động đc vào 1 file là quyền execute (x). ví dụ có quyền r nhưng ko x thì ko mở đc file)
				+ read:		4	r
				+ write:	2	w	
				+ execute:	1	x
				+ full:		7			(7=4+2+1=rwx, 6=4+2=rw-, 5=4+1=r-x, 3=2+1=-wx, 2=-w-, 1=--x, 0=---=no permissions)
				
				+ formart: drwx.../-rwx: d=directory, -=file
					* drwxr-xr-x   2 root root       4096 Oct  7 17:08 srv
					* lrwxrwxrwx   1 root root          7 Oct  7 08:35 bin -> usr/bin
					* -rw-------   1 root root 4105175040 Jan  3 05:39 swap.img
					
				+ chmod -R u=rwx,g=rx,o=- folder/filename							// -: xóa, +: thêm, =: set
				+ chmod -R 777 folder/filename:	change mode for open to all user	(chmode ugo filename)
				+ chmod -R o+x folder/filename			/u+rwx		/go-w		/u+rw,go+r		/
				
		+ Tư duy triển khai dự án:
			+ Project:
				- Project type: Frontend | Backend
				- Tool deploy project | version of tool: version tương thích với yêu cầu của project
				- Files:
					+ File chức năng:	file code										-> not
					+ File cấu hình:	config, port, connection, connect database		-> DevOps takecare
					+ File khác:														-> not
				
				- Deploy: 2 steps
					+ 1. Build: command build file/folder
					+ 2. Run:	run file/folder
					
			+ DevOps: 4 steps
				- 1. Công cụ j?
				- 2. File cấu hình ở đâu?
				- 3. Làm sao build?
				- 4. Run thế nào?
				
				- Note:
					+ mỗi project có 1 thư mục làm việc riêng
					+ mỗi project có user riêng
					--> ko dùng user root để deploy dự án, nếu bị chiếm quyền thì ảnh hưởng toàn bộ hệ thống 
					--> giải pháp: tạo riêng user cho mỗi thư mục riêng của dự án, và user đó chỉ có quyền trong thư mục riêng đó thôi và chỉ chạy bởi user đó
					
			+ Deploy Frontend: Vue/React: 4 steps - todolist/vision
				// 0: user root
				+ copy dự án lên server: scp projectFile serverAddr = scp E:/DevOps/todolist.zip ngocnm@192.168.56.101:/home/todolist
				+ giải nén: unzip todolist.zip /projects
				+ tạo user riêng cho project: adduser todolist
				+ set owner & mode cho folder /projects/todolist/: 
					- chown -R todolist:todolist /projects/todolist/
					- chmod -R 750 /projects/todolist/
				// 1. 
				+ install packages: 		sudo apt install nodejs nginx npm -y		(user root)
				+ install dependencies:		npm install									(user todolist)
				// 2.
				+ Configs:
					- package.json:
						+ "scripts": 
							- "serve":	
							- "build": ~ build project ~ npm run build "params=vue-cli-service build"
					- vue.config.js: export port ~ 3000, ...
				// 3.
				+ build: 					npm run build 		--> build ra folder /dist/ (vue) - /build/ (react)		(user todolist)
					- Reactjs project: got error -> digital-envelope-routinesunsupported
						- Fixed: Add a file called .npmrc in the root of the project, and add this to the file: 	node-options="--openssl-legacy-provider"
							export NODE_OPTIONS=--openssl-legacy-provider && react-scripts build		/ 			react-scripts --openssl-legacy-provider build
						- Cannot find module 'ajv/dist/compile/codegen':	npm install ajv@latest ajv-keywords@latest
						- export NODE_OPTIONS=--max_old_space_size=4096:	export NODE_OPTIONS=--max_old_space_size=4096
				// 4.
				+ run:	3 ways for run frontend project
					- way1: 	web server					nginx
					- way2: 	service					
					- way3: 	pm2 ??						
					
					- local:	npm run serve				(serve in scripts config)
			
			+ Nginx: 		(user root) - sau khi build project xong -> step 4: run project by webserver
				- install: apt install nginx -> default port 80: 
				- configs: /etc/nginx: subfolders [sites-available, conf.d]
					+ 1. sites-available/default: set port 8080 --> test syntax: nginx -t  --> apply new config: systemctl restart nginx / nginx -s reload (systemctl restart nginx: restart all nginx cho all project - ko nên dùng)
					+ 2. add file config for each project to subfolder /conf.d: /etc/nginx/conf.d/todolist.conf
						server {
							listen 		8081; // port
							root 		/projects/todolist/dist/; // build folder
							index 		index.html;
							try_files	$uri $uri/ /index.html;
						}
		
					+ 3. add group owner cho user nginx: default user nginx is www-data, ko có quyền chạy todolist, todolist is run with groupOwner todolist nên ko chạy đc -> error 500
						- usermod -aG todolist nginx
				
				- work folder: /usr/share/nginx/html/
						
			+ Service: 		(user root) - run by service, tương tự như system service - systemctl
				- location:	/lib/systemd/system/
				- tao file config service: vi /lib/systemd/system/vision.service
					[Service]
					Type=simple
					User=vision
					Restart=on-failure							// khi service bi die thi tu restart lai
					WorkingDirectory=/projects/vision/
					ExecStart=npm run start -- --port=3000
					
				- run: systemctl daemon-reload 		--> 	systemctl restart vision (.service) 	--> 	systemctl status vision
				
			// 192.168.56.104/24			10.0.2.15/24
			
			+ Deploy Backend: Java spring boot 
				- install java, maven:	 	apt install openjdk-17-jdk openjdk-17-jre maven -y				(user root)
				- install database:			apt install mariadb-server -y									(user root)
					+ config: 				systemctl stop mariadb 									--> 	/etc/mysql/mariadb.conf.d/xx_server.cnf:	bind-address = 0.0.0.0 ~ access from any where		--> 	systemctl restart mariadb
					+ Create db:			mysql -u root --> mysql command:
						- show databases;
						- create database dbName;													
						- create user 'userName'@'%' identified by 'passw';							--> ('%' = scope, có thể truy cập đến tất cả các server)  mỗi db nên có 1 user riêng để truy cập đến, ko dùng user root
						- grant all privileges on dbName.* to 'userName'@'%';						--> gán quyền cho user để tác động lên db
						- flush privileges;															--> save db setting
						- exit
						
					+ Connect db:	(user root)		mysql -h (host) 192.168.56.10 (IP server) -P (port) 3306 -u userName -p (passwd)		--> mysql command
						- use dbName;																--> use shoeshop;
						- show tables;
						- source pathOfDbFile;														--> source /projects/shoeshop/shoe_shopdb.sql;		--> show tables;			// import database from db file
						
				- Config: 	(user root)
					+ link to database: edit src/main/resource/application.properties				--> 
						- spring.datasource.url=jdbc:mysql://<address_server>:<port>/<database_name>//?useSSL=false		-> 		Unable to acquire JDBC Connection with root cause java.security.cert.CertificateNotYetValidException: NotBefore
						- spring.datasource.username=<username>
						- spring.datasource.password=<password>
						- server.port=8090																// Web server failed to start. Port 8080 was already in use.
						
						// option
						- spring.datasource.validation-query=select 1									
							spring.datasource.testOnBorrow=true									
							spring.datasource.hikari.maximum-pool-size=10						
						
				- build:	(user shoeshop)			mvn install -DskipTests=true						(-DskipTests: bỏ qua maven auto test)				--> build ra 'target' folder
					
				- run:		(user shoeshop)			nohup java -jar target/pathOfJarFile 2>&1 &		(nohup: auto save log to nohup.out file, 		2>&1 &: chạy background -> kill process: kill -9 pId, -9=buộc dừng)
													nohup java -jar target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar 2>&1 &								// -Djava.net.preferIPv4Stack=true: set IPv4  		-Djava.net.preferIPv6Addresses=false
				- ps -ef| grep shoeshop				(ps -ef: output của câu trước là input của câu sau;		grep xxx: tìm kiếm)

	1.2. Git
		+ Architect
			- 	 							Local												Remote (server)
					Working directory		Staging area			Local repo					  Remote repo / registry
						Edit file 	------>		git add	   ------>   git commit -------> git push ----->	
																		<-------------- git pull/fetch
							<--------------------------------------- git checkout
							<--------------------------------------- git mergre
							
			- Commit covention:
				<type>[optional scope]: <description>		// scope: project, module, lib, feature
				[optional body]								// details, keywords	
				[optional footer] / BREAKING CHANGE			// issue, ID, ...
				
				+ feat: 	thêm một feature
				+ fix: 		fix bug cho hệ thống, vá lỗi trong codebase
				+ refactor: sửa code nhưng không fix bug cũng không thêm feature hoặc đôi khi bug cũng được fix từ việc refactor.
				+ docs: 	thêm/thay đổi document
				+ chore: 	những sửa đổi nhỏ nhặt không liên quan tới code
				+ style: 	những thay đổi không làm thay đổi ý nghĩa của code như thay đổi css/ui chẳng hạn.
				+ perf: 	code cải tiến về mặt hiệu năng xử lý
				+ vendor: 	cập nhật version cho các dependencies, packages.
				+ ci: 		Thay đổi liên quan đến cấu hình CI
				+ build, test, ...
				+ Optimize, Bump, Drop, ...
				
				+ BREAKING CHANGE: Nhưng commit mới footer là BREAKING CHANGE thể hiện những thay đổi gây ảnh hướng lớn đến source code ví dụ thay đổi kiểu dữ liệu, cách lấy dữ liệu… => Qua đó cảnh báo mọi người để tránh phát sinh các vấn đề.
				
				+ generate CHANGELOGS cho dự án, team sẽ sử dụng 1 plugin của fastlane có tên là Secmantic_release
		
		+ Git workflow: manage & deploy for envinroment: development - staging - production
			- main branches						tag:release						tag:release						tag:release				// production
			
					+ hotfix		*
					
					+ release									*									*									// staging
					
					+ develop	*	*		*		*		*		*		*		*		*											// development
						- feature 1			x
						- feature 2					x
						- ....
						
			- Steps:
				+ 1. create project/branch: create project & main branche  -> branch out: develop / release / hotfix
				+ 2. development:			develop branch  ->  create feature branches  ->  dev code  -> merge: feature -> develop
				+ 3. release:				merge code from develop branch to release branch ->  test 
												- test pass: merge code release -> main: add Tag -> deploy = production
												- test fail: merge code release -> develop -> feature: fixed issue -> merge code: feature -> develop -> release -> retest -> ...
				+ 4. hot fix:				merge code from main to hotfix (at commit of release:tag) -> fixed:
												- merge code from hotfix to main: 		version up & continous release on main branch
												- merge code from hotfix to develop:	-> branch out feature: develop -> release -> ...
			
			
				+ Git in Samsung = gerrit: all dev alway push code to main branch: all code alway on main branch
					- dev -> push main branch from local repo: review +1/+2 & submit(=merge code) -> self test ok: version up main branch(= release) -> tester test: ...
						+ got issue: fix in local repo -> push main branch: review & merge -> cherrypick to production branch -> version up: main & production -> tester test again.
					-
			
			- Gitflow:
				+ VCS: version control system
					- Centralized Version Control:	SVN
					- Distributed Version Control: 	Git
				+ 4 Gitflow:
					- Centralized: Đây là workflow cơ bản nhất, với 1 branch duy nhất, mọi người trong team đều làm việc chung trên này.
						+ Nó giống hệt với SVN nói riêng và các centralize version control khác. Vậy nên nó không tận dụng được hết những tính năng cũng như ưu điểm của git. 
						+ Flow này áp dụng cho những team mới áp dụng git, những dự án nhỏ, có vòng đời phát triển ngắn. 
						+ Hoặc flow này có thể áp dụng như giai đoạn trung gian của việc chuyển dự án từ SVN sang Git.
					
					- Feature branch workflow: only main branch & feature branches: merge feature branches to main branch -> conflic: tự handle
						+ pull request: leader & team review code trc khi merge vào main branch.
						+ ứng dụng được nhiều điểm mạnh của git, thích hợp cho những dự án phát triển với team nhỏ và vừa. 
						+ Nhưng với những dự án lớn hơn, những team lớn hơn, hay đơn giản là khi cần thiết phải chia role cho các branch, chứ không đơn thuần là chỉ có branch master và các feature branch.  ->  Gitflow Workflow
						
					- Gitflow Workflow: main, develop, feature, release, hotfix
					
					- Forking workflow: Tách ra để đi nhanh hơn, hợp lại để đi xa hơn -> Fork repo trên github
						+ mỗi ng 1 repos khác nhau, fork từ repos base, tự  phát triển khác nhau, sau muốn merge lại thì tạo pull request
			
		+ Gitlab:
			- Install: search gitlab-ee package ubuntu install
			- Define domain for gitlab:	
				+ nano /etc/hosts:							add line - 192.168.56.30 gitlab.devops.tech			-> saved
				+ nano /etc/gitlab/gitlab.rb:				exteral_url 'http://gitlab.devops.tech'				-> login gitlab admin by this domain				
					-> check value: /var/opt/gitlab/.gitconfig		/var/opt/gitlab/nginx/conf/gitlab-http.conf		/var/opt/gitlab/gitlab-kas/gitlab-kas-config.yml
					-> gitlab-ctl reconfigure / gitlab-ctl restart / gitlab-rake cache:clear
				+ edit host of Windows:						“ C:\Windows\System32\drivers\etc\hosts ”				-> add line: 192.168.56.30 gitlab.devops.tech		-> replace				// Linux: /etc/hosts
				+ cat /etc/gitlab/initial_root_password 	default usser/password
				
				+ Để các server khác truy cập được vào domain gitlab thì cần add host domain cho tất cả các server đó
				
				+ Convert domain:port về defalut domain:
					- 
		
			- Mỗi project nên tạo 1 group trên gitlab để chứa các service của project: service frontend, service backend (micro service)
			
			- Tag: mỗi branch có thể tạo tag, là điểm đánh dấu và là dấu hiệu để làm CI/CD
			
			- add SSH key for Gitlab:
				+ gen SSH key for local
				+ add SSH key on Gitlab server for each account
				
			- Merge request:	fast-forward / non fast-forward
				+ mỗi developer đều đc approve merge request, chỉ maintainer mới có approve + merge
				+ trước khi merge: rebase or squash commit: -> gộp nhiều commit nhỏ lại với nhau để ít commit trong history
				+ merge fast-forward:  git merge login 					/ merge non fast-forward: git merge login --no-ff
				+ ordered: feature merge to dev		dev merge to release		release merge to main 
				
			- Cherrypick: tạo 1 merge request mới với branch cherrypick mới
			
			- Project config:
				+ Project Infomation: 
					- Activity:		Event: push, merge, Issue, Comment, ...
					- Labels:		label applied to issue/merge request: bug, critical, discussion, ...
					- Members:		manage list members
				
				+ Repository: manage
					- Files / Commits / Branches / Tags
					- Tags: mỗi branch có thể tạo tag, là điểm đánh dấu release và là dấu hiệu để làm CI/CD
					
				+ Issues:
					- Milestones: tổng quan của 1 bản release [issue, merge request], status: upcoming, complete
					
				+ Merge requests:
					- khi merge một nhánh vào thì tất cả commit của nhánh đấy cộng với một commit mới (gọi là meta merge commit) sẽ được thêm vào nhánh chỉ định
					- git merge --squash --edit: dồn tất cả commits của feature branch thành 1 commit duy nhất trước khi merge	(~ git rebase -i ... ), và hỏi người dùng tên commit mới là gì rồi sẽ merge vào branch, muốn edit commit message thì thêm '--edit'
				+ CI/CD:
					- Pipelines / Editor:
					- Jobs / Schedules
					
					- Pipelines: là component lớn nhất của quy trình tích hợp được chạy dài từ đầu tới cuối, phân phối và triển khai liên tục (Pipelines are the top-level component of continuous integration, delivery, and deployment)
						+ Types:
							- Jobs : Các công việc được giao thực thi (Ví dụ: biên dịch mã hoặc chạy test)
							- Stage : Xác định các thời điểm và cách thực hiện. (Ví dụ: test chỉ chạy sau khi biên dịch thành công)
						+ Nguyên tắc hoạt động:								https://tigosoftware.com/vi/duong-ong-tich-hop-cicd-pipeline-la-gi
							- Tất cả các công việc trong cùng một stage được Runner thực hiện song song, nếu có đủ số lượng Runner đồng thời.
							- Nếu Success, pipeline chuyển sang stage tiếp theo.
							- Nếu Failed, pipeline sẽ dừng lại. Có một ngoại lệ là nếu job được đánh dấu làm thủ công, thì dù bị fail thì pipeline vẫn tiếp tục.
							
					- Một Runner có thể là một máy ảo (VM), một VPS, một bare-metal, một docker container hay thậm chí là một cluster container. 
					- Gitlab và Runners giao tiếp với nhau thông qua API, vì vậy yêu cầu duy nhất là máy chạy Runner có quyền truy cập Gitlab server.
					- các Runner thực thi các jobs được định nghĩa trong file .gitlab-ci.yml.
					- Một Runner có thể xác định cụ thể cho một dự án nhất định hoặc phục vụ cho nhiều dự án trong Gitlab. Nếu nó phục vụ cho tất cả project thì được gọi là Shared Runner.
				+ Security and Compliance
				+ Deployments
				+ Packages and registries
				+ Infrastructure: 			Kubernetes clusters / Terraform
				+ Monitor:					Metrics / Error Tracking / Alerts / Incidents
				
				+ Settings:
					- Repository: 			protected branches [Roles: Maintainer / Developer + Maintainer / No one]				// no Observer
					- Merge request:		merge commit / Merge commit with semi-linear history (conflict -> rebase) / Fast-forward merge ((conflict -> rebase)
					- 	
				
	1.3. CI/CD:	gitlab / jenkins		-	commit -> build -> test -> deploy	(automactic - not manual, avoid mistake)
		+ CI: Continuous Integration																							// clone code -> build -> test: pef, security, clean code, ...
		+ CD: Continuous Deployment(Auto - increase pef, decrease time) / Continuous Delivery(Manual - increase control)		// deploy
		
		+ normal process: dev: code -> tester: test -> devops deployment, monitoring, setup system, maintain & upgrade system
		+ Tools: Gitlab CI/CD / Jenkins:
			+ 1. Install tool: Gitlab runner, Jenkins
			+ 2. Write scenario
		
		+ Gitlab: 
			- 1. Install runner:
				+ Install gitlab-runner on gitlab-server, then add token: 
					- curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
						apt install gitlab-runner	-> working directory= /home/gitlab-runner;			gitlab-runner register -> enter gitlab domain, token (Settings of project CI/CD: Runner: Tokens)
					- Executor: 	shell, docker, kubernetes
					- Config:		/etc/gitlab-runner/config.toml			-> edit: concurrent = 4 -> runner có thể chạy đồng thời 4 dự án khác nhau, nếu = 1 thì dự án sau phải chờ dự án trước chạy xong mới chạy đc
				+ Start runner:		nohup gitlab-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --user gitlab-runner 2>&1 &
				+ Check runner:
					- gitlab-runner list			- gitlab-runner unregister --url https://gitlab.org/ --token {TOKEN}			- gitlab-runner start/stop/restart
			
			// nen tao user rieng de chay cho moi project, khong nen dung user gitlab-runner
			// user: gitlab-runner can duoc su dung sudo ma khong can password (chi ap dung cho 1 so command):		maybe add for user shoeshop if it has passwd			
				+ visudo:		edit file 
				+ add lines: 	gitlab-runner ALL=(ALL:ALL) NOPASSWD: /bin/cp*					// (ALL:ALL)=(user:group)
								gitlab-runner ALL=(ALL:ALL) NOPASSWD: /bin/chown*
								gitlab-runner ALL=(ALL:ALL) NOPASSWD: /bin/su shoeshop
			
			- 2. Write scenario: 	.gitlab-ci.yml		-> CD = Continuous Deployment + Continuous Delivery
					stages: 
						- build
						- deploy
						- showlog
					
					build:
						stage: build
						variables:
							GIT_STRATEGY: clone/none											// clone src code khi chay stage or not
						script:
							- whoami
							- pwd
							- ls
							- mvn install -DskipTests=true
						tags:
							- gitlab-runner
					
					deploy:
						stage: deploy
						variables:
							GIT_STRATEGY: none
						script:
							- java -jar target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar
						tags:
							- gitlab-runner
							
				+ Run project by correct user: shoeshop
					- mkdir /datas/shoeshop/				adduser shoeshop
					- edit deploy stage: added global variables
						variables:
							projectname: shoe-ShoppingCart
							version: 0.0.1-SNAPSHOT.jar
							projectuser: shoeshop
							projectpath: /datas/$projectuser/
						build:
							....
						
						deploy:
							stage: deploy
							variables:
								GIT_STRATEGY: none
							when: manual																														// set to run manualy
							script:
								- >																																// start rules
									if ["$GITLAB_USER_LOGIN" == 'ngocnm']; then
										sudo cp target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar /datas/shoeshop/													// copy file
									else
										echo "Permission denied"
										exit 1																													// exit pipeline
									fi
									
								- sudo cp target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar /datas/shoeshop/															// copy file
								- sudo cp target/$projectname-$version.jar $projectpath																			// copy file
								- sudo chown -R shoeshop.	/datas/shoeshop/			$projectpath															// permission
								- sudo su shoeshop -c "kill -9 $(ps -ef | grep shoe-ShoppingCart- | grep -v grep | awk '{print $2}')"							// kill pId by pId=ps -ef | grep shoe-ShoppingCart-0.0.1-SNAPSHOT.jar | grep -v grep | awk '{print $2}' 
								- sudo su shoeshop -c "cd /datas/shoeshop/; nohup java -jar target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar > nohup.out 2>&1 &"		// switch user; -c=command (run commands in "...")
							tags:
								- gitlab-runner
							only:
								- tags																															// chỉ deploy dự án khi có tag mới đc tạo		
				
			- Một Runner có thể là một máy ảo (VM), một VPS, một bare-metal, một docker container hay thậm chí là một cluster container. 
			- Gitlab và Runners giao tiếp với nhau thông qua API, vì vậy yêu cầu duy nhất là máy chạy Runner có quyền truy cập Gitlab server.
			- Các Runner thực thi các jobs được định nghĩa trong file .gitlab-ci.yml.
			- Một Runner có thể xác định cụ thể cho một dự án nhất định hoặc phục vụ cho nhiều dự án trong Gitlab. Nếu nó phục vụ cho tất cả project thì được gọi là Shared Runner.
			
			- Thực hành (Best Practices): Dưới đây là các bước thông thường của quá trình release tính năng trong một dự án thuộc hệ thống Teamcrop.
				Bước 1: 	[Manual] 	Khởi tạo repository và có branch default là master và dev. Cài đặt trên Gitlab 9.
				Bước 2: 	[Manual] 	Trừ owner ra, thì các coder sẽ push code tính năng lên branch dev
				Bước 3: 	[Auto] 		Hệ thống tự động thực hiện test source code, nếu PASS thì sẽ deploy tự động (rsync) code lên server beta.
				Bước 4: 	[Manual] 	Tester/QA sẽ vào hệ thống beta để làm UAT (User Acceptance Testing) và confirm là mọi thứ OK.
				Bước 5: 	[Manual] 	Coder hoặc owner sẽ vào tạo Merge Request, và merge từ branch dev sang branch master.
				Bước 6: 	[Manual] 	Owner sẽ accept merge request.
				Bước 7: 	[Auto] 		Hệ thống sẽ tự động thực hiện test source code, nếu PASS sẽ enable tính năng cho phép deploy lên production server.
				Bước 8: 	[Manual] 	Owner review là merge request OK, test OK. Tiến hành nhấn nút để deploy các thay đổi lên môi trường production.
				Bước 9: 	[Manual] 	Tester/QA sẽ vào hệ thống production để làm UAT và confirm mọi thứ OK. Nếu không OK, Owner có thể nhấn nút Deploy phiên bản master trước đó để rollback hệ thống về trạng thái stable trước đó.
				Bước 10: 	[Manual] 	Chờ biên bản nghiệm thu cho giai đoạn triển khai mới, hãy kiên trì lắng nghe khách hàng và chủ động "phòng thủ" từ xa (preventive actions).
	
	1.4. Docker
		+ Docker là công cụ ảo hóa dạng container, tạo 1 envir độc lập giúp đóng gói project + dependencies( = docker image) vào 1 container duy nhất để có thể chạy / deploy trên nhiều môi trường, thiết bị khác nhau 1 cách linh hoạt, ko phụ thuộc vào nền tảng.
		
		+ Docker architect:		code			dockerfile					docker image							docker hub								Devices
			- 					(dev)			  (write)	-> build ->		(container)		-> push image ->		(repo - remote)		-> pull image ->	run in container
		
		+ Install docker:						https://devopsedu.vn/courses/devops-for-freshers/lesson/bai-19-cach-su-dung-docker/
			- mkdir tools/docker		-> 		touch tools/docker/install-docker.sh
			- Run:	.install-docker.sh 			sh install-docker.sh 					bash install-docker.sh
			- way2:	apt install docker-ce		https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04
			
		+ Pull & run docker image from docker hub:					https://hub.docker.com/
			- docker pull ubuntu:2204								-> pull imageName:tag, nếu ko có tag = latest
			- docker images											-> check images: show Repo/Tag/ImageId/Created/Size
			
			- docker run --name containerName -it imageName:tag		-> vào bash of container (chỉ run 1 lần đầu tiên)				(exit: stop container)		(tự pull từ docker hub về nếu local chưa pull)		// ubuntu
			- docker run --name nginx -dp 9999:80 -it nginx			-> pull & run nginx (-d: run in background, -p: port, 9999: port run outside = port of server, 80: port of container - listen in container)		// web server
			- docker exec -it containerName command(bash)			-> truy cập lại envir container sau khi run & exit				(-it: truy cập vào bash của container)											// run local container
				+ docker exec -it ubuntu bash/sh					-> vao container envr
			
			- docker ps -a											-> show containsers are running (-a: show containsers exits)	ContainerId/Image/Command/Status/Ports/Names
			- docker start containerName/containerId				-> start lại container, dùng Id chỉ cần 3 ký tự đầu
			- docker stop containerName/containerId
			
			- docker stop/rm $(docker ps -a -q)						-> stop/rm all containers (docker ps -a -q = containerId)		docker rm -f containerName/containerId
			- docker rmi imageName:tag								-> xóa image
			
			- docker build -t imageName:tag	-f Dockerfile			-> build project to docker image
			- docker logs -f containerName							-> xem log
			
			- docker hub: push image
				+ docker login 	[url/domain]						// login by username & passwd, no url=hub.docker.com 			-> docker logout
				+ docker pull domain/project/repo:tag
				+ docker tag imageName:tag imageFormat				-> imageFormat: domain/project/repo:tag							// bản chất là copy sang 1 image khác
				+ docker push domain/project/repo:tag				// format: domain/project/repo:tag
				
			- docker save <image> | bzip2/gzip | pv | ssh user@host docker load
			- docker save -o <path for generated tar file> <image name>									/			docker load -i <path to image tar file>
		
		+ Write docker file: dockerize project	-> config để đưa src code vào container & install các tools để chạy project
			- Commands:
				FROM imageName(node:20)			-> pull image from docker hub
				WORKDIR /app					-> chỉ định thư mục làm việc (chưa có /app thì tự tạo /app)
				COPY . .						-> copy src code tại vị trí dockerfile đang đứng vào container: WORKDIR = /app
				RUN command						-> command: build / run
				
				ENV 							-> khai bao bien moi truong						ENV JAVA_OPTIONS="-Xmx2048m -Xms256m"
				EXPOSE port						-> define port: port server : port container
				CMD ["command", "params", ...]	-> xác định lệnh và giá trị mặc định
				ENTRYPOINT command 				-> giữ nguyên lệnh cố định và cho phép lệnh đc chỉ định khi container chạy thêm vào cuối của nó
				
				USER userName
			
			- Tip security / optimize:
				+ non root user:				-> for security
				+ chọn base image phù hợp:		->
					- đúng version /Java 8 		-> nên cài maven java 8 để build & run: tối ưu dung lượng docker image build ra & hạn chế tools ko cần thiết làm tăng size
					- ubuntu/cenos				-> nên chọn image đc build sẵn dựa trên alpine vì nhẹ và tối ưu
					- base image uy tín			-> nên chọn : offical / verified / sponsored
					- tool quét image			-> check lỗ hổng
				+ use Multiple stage: 			-> giảm size docker image cuối cùng đc build ra
				
		+ Dockerize project: backend
			- cd ../project/
			- create docker file:		../project/Dockerfile		../project/Dockerfile-v2 
				+ ## build state
					FROM maven:3.5.3-jdk-8-alpine as build						# tạo input build cho run state
					WORKDIR /app
					COPY . .
					RUN mvn install -DskipTests=true								# build folder: /app/target
					
				+ ## run state
					-------------------------------------------------------------------------
					# using existing alpine from docker hub
					FROM amazoncorretto:8u402-alpine-jre
					-------------------------------------------------------------------------
					
					-------------------------------------------------------------------------
					# tự build alpine
					FROM alpine:3.19											# using original alpine
					RUN apk add openjdk8										# install java 8 for alpine
					-------------------------------------------------------------------------
					
					WORKDIR /run/shoeshop
					COPY --from=build /app/target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar /run/shoeshop/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar
					
					# config user for run
					RUN adduser -D shoeshop										# create user
					RUN chown -R shoeshop:shoeshop /run/shoeshop
					USER shoeshop
					
					EXPOSE 8080													# container port
					ENTRYPOINT java -jar /run/shoeshop/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar
					CMD ["nginx", "-g", "daemon off;"]
					
			- docker build -t imageName:tag	-f fileConfigName .
			- docker run --name containerName -dp 9999:80 -it imageName:tag								# mỗi container ~ 1 server riêng biệt
			- docker log -f containerName					# xem log
			- docker exec -it containerName sh				# vào môi trường containerName -> run sh
			
			- push imageName to docker hub / registry 		# push registry
			
			* Note: size of image chỉ phụ thuộc step run, ko phục thuộc step build
		
		+ Dockerize project: frontend
			- 
			
		+ Example: https://elroydevops.tech/mau-dockerfile-cac-du-an/
		
		+ Docker registry:
			- docker hub: ko dùng trong enterprise envr			- above
				+ docker login 	[url/domain]						// login by username & passwd, no url=hub.docker.com 			-> docker logout
				+ docker pull domain/project/repo:tag
				+ docker tag imageName:tag imageFormat				-> imageFormat: domain/project/repo:tag							// bản chất là copy sang 1 image khác
				+ docker push domain/project/repo:tag				// format: domain/project/repo:tag
				
			- private registry: use https, auto verified					- ko dùng trong enterprise envr, self-verified
				+ verified:		mkdir /tools/docker/registry/				-> cd /tools/docker/registry/			
								mkdir /tools/docker/registry/certs & data
					- install:		apt install openssl -y					// using https, not http
					- reg key:		openssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key -subj "/CN=192.168.1.100" -addext "subjectAltName=DNS:192.168.1.100,IP:192.168.1.100" -x509 -days 3650 -out certs/domain.crt 
					- nano docker-compose.yml:
						version: '3'
						services:
						  registry:
							image: registry:2
							restart: always
							container_name: registry-server
							ports:
							  - "5000:5000"
							volumes:
							  - ./data:/var/lib/registry
							  - ./certs:/certs
							environment:
							  REGISTRY_HTTP_TLS_CERTIFICATE: certs/domain.crt
							  REGISTRY_HTTP_TLS_KEY: certs/domain.key
						// end
					- docker-compose up -d											// download registry 2
					- docker-compose ps 											// show list registry-server				access registry-server: https://192.168.56.10:5000/v2/_catalog  	--> 	{ "repositories": [] } // empty repositories
					- docker-compose logs/pause/unpause/stop/up/down
					
				+ basic authentication:
					- docker login 192.168.56.10									// login server by any username & passwd because self-verified
					// authenticate IP server = verify certificate
					- copy cert to authentication folder of this registry-server and 'pushed' server (gitlab, ...)
						+ create sub folder: ../certs.d/192.168.56.10:5000/ in folder: /etc/docker/			mkdir -p /etc/docker/certs.d/192.168.56.10:5000
						+ copy cert:																		cp 	/tools/docker/registry/certs/domain.crt 	/etc/docker/certs.d/192.168.56.10:5000/ca.crt
					
					// push image
					- docker tag imageName:tag domain/project/repo:tag				-> imageFormat: domain/project/repo:tag			// bản chất là copy sang 1 image khác
					- docker push domain/project/repo:tag							// format: domain/project/repo:tag				// 192.168.56.10:5000/devops/shoeshop:v3	
					- docker pull 192.168.56.10:5000/devops/shoeshop:v3
				
				+ docker-compose.yml for web:
					- 	version: '3.7'
						services:
						  web:
							image: nginx:alpine
							ports:
							  - "8000:80"
							volumes:
							  - ./app:/usr/share/nginx/html
						// end
			- harbor: cần mua domain (50k), thuê vps giá rẻ		- 	
				+ vps: 		aws EC2
					- aws EC2:
						+ Free tier: EC2 - 750h/month + 5Gb
						+ Launch instance -> Ubuntu + Free tier: t2.micro -> save key pair RSA -> Allow HTTP/HTTPS -> Connect Instance: save static IP -> access by terminal
						+
				+ domain:
					- DNS: elroydevops.online
					- domain: add record -> type=A, name=registry.elroydevops.online	-> set static IP from EC2
					
				+ setup: on EC2
					- install docker				install certbot: for authentication
					- mkdir /harbor					install harbor on/offline						tar xvzf harbor-offline
					- config: 						cd harbor										cp harbor.yml.tmpl harbor.yml
					- khai báo biến:				export DOMAIN="registry.elroydevops.online"		export EMAIL="elroydevops@gmail.com"
					- certbot certonly --standalone -d &DOMAIN																// 
					- 
		
		+ Docker component:
			- Docker volume
			- Docker compose
			- Docker network
		
		+ Docker & Gitlab CI/CD:
			- usermod -aG docker gitlab-runner					// add group docker for user gitlab-runner, để gitlab có thể run docker
			- image format domain/project/image:tag_commit		-> add variables for Gitlab: project settings -> CI/CD -> Variables -> add variables for registry:	REGISTRY_URL / PROJECT / VERSION / USER / PASSWORD
			- edit .gitlab-ci.yml:																										Gitlab variables:			CI_PROJECT_NAME, CI_COMMIT_TAG, CI_COMMIT_SHORT_SHA
				+ variables global:		
					- DOCKER_IMAGE: 		${REGISTRY_URL}/${REGISTRY_PROJECT}/${CI_PROJECT_NAME}:${CI_COMMIT_TAG}_${CI_COMMIT_SHORT_SHA}
					- DOCKER_CONTAINER:		$CI_PROJECT_NAME
				+ build&push:
					- before_script: 	docker login ${REGISTRY_URL} -u ${REGISTRY_USER} -p ${REGISTRY_PASSWORD}
					- script:			docker buil -t ${DOCKER_IMAGE} .												docker push $DOCKER_IMAGE
				+ run:
					- before_script: 	docker login ${REGISTRY_URL} -u ${REGISTRY_USER} -p ${REGISTRY_PASSWORD}		docker pull $DOCKER_IMAGE
					- script:			docker rm -f $DOCKET_CONTAINER
										docker run --name $DOCKET_CONTAINER -dp 8080:8080 $DOCKER_IMAGE					// note: port in Dockerfile must same containerPort in run command: -dp 8080:8080 and not use port which is running on server
				+ showlog:
					- script:			docker logs $DOCKER_CONTAINER
			- note: 
				+ REGISTRY_URL: 
					- harbor registry: 		server.example.com
					- private registry:		192.168.56.10:5000			// trước hết cần add cert cho gitlab để truy cập docker registry; need port, nếu convert được 192.168.56.10:5000 sang domain server.example.com thì dùng server.example.com
		
	1.5. Jenkins:
		- Define:				1 máy chủ tự động hóa (open source) hàng đầu, cung cấp nhiều plugins hỗ trợ xây dựng, triển khái và tự động hóa bất kì project, ko chỉ là CI/CD		- language: groovy
		- install jenkins:		create file: /tools/jenkins/jenkins-install.sh				-> 		run: chmod +x ../jenkins-install.sh (cap quyen execute)				sh/bash ../jenkins-install.sh
									#!/bin/bash
									apt install openjdk-17-jdk -y
									java --version
									wget -p -O - https://pkg.jenkins.io/debian/jenkins.io.key | apt-key add -
									sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
									apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 5BA31D57EF5975CA
									apt-get update
									apt install jenkins -y
									systemctl start jenkins
									ufw allow 8080					# open firewall port 8080 for jenkins
								
								+ add host for jenkins-sever & window host: 192.168.56.40 jenkins.devops.tech
								+ reverse proxy: 
									- dung webserver: 	nginx
									- file config:		nano /etc/nginx/conf.d/jenkins.devops.tech.conf
										server {
											listen 80;
											server_name jenkins.devops.com;
											location / {
												proxy_pass http://jenkins.devops.com:8080;
											}
										}
								+ neu co nhieu version java:	update-alternatives --config java -> select jdk muốn dùng
								
		- Jenkins: la noi chay pipeline, ko deploy project tren jenkins server
		- Manage Jenkins:
			+ System:	
			+ Plugins:	add/remove plugin
			+ Nodes: 	add node server agent vao jenkins server -> dung jenkins agent de connect toi cac server deploy project, ko su dung ssh vi rat nguy hiem (ket noi p2p)
			+ Security:	phan quyen, jenkins defalut ko co phan quyen, cài plugin để phân quyền
			+ Crendentials:		save password, private key, ...
			+ Users:
			+ Systemlog:	
			+ Jenkins CLI: 		hoàn toàn tự động mọi thứ
		
		- Jenkins CI/CDeployment:
			// 1. kết nối jenkins-server đến lab-server: 		jenkins Agent
			+ Jenkins Agent:				java version on client ~ java version on Jenkins server install (thay vì dùng ssh - kết nối ngang hàng, ko bảo mật, dễ gây lỗi)
				- lab-server: 				
					+ install java version for node (same java version on jenkins): apt install jdk...
					+ adduser jenkins
					+ add folder: /var/lib/jenkins (nơi lưu các project cần triển khai trên lab-server)		-> 		chown -R jenkins. /var/lib/jenkins
					+ để user jenkins chạy đc file project (.jar) thì cần gán quyền NOPASSWD cho user jenkins giống user gitlab-runner
				- Jenkins:				
					+ add Node:		
						- number of executors: 	số pipeline đc chạy cùng lúc	-	Custom workdir path / Remote root directory: 1 folder on lab-server (/var/lib/jenkins)
						- port/inbound:			create fixed port in Security (ko đc trùng port)	
						- save:					click to node to show config to connect client -> run from agent command line, with the secret stored in a file		-> node not running
				- lab-server:			su jenkins	-	cd /var/lib/jenkins														// ko dùng user root
										// save secret key and agent.jar file
										echo 377af60a51c9471b486e10c4b928ca5fb66c430986e337b67162df2bdc101e1a > secret-file
										curl -sO http://jenkins.devops.tech:8080/jnlpJars/agent.jar
										// start runing node
										java -jar agent.jar -url http://jenkins.devops.tech:8080/ -secret @secret-file -name "lab-server" -webSocket -workDir "/var/lib/jenkins" > nohup.out 2>&1 &
			
			// 2. kết nối jenkins-server đến gitlab-server: 	2.1. plugin-gitlab & BlueOcen		2.2. tạo pipeline CI/CD
			+ Jenkins Gitlab:
				// 2.1. Kết nối jenkins-server đến gitlab-server
				- Gitlab:
					+ tạo user jenkins có quyền admin, để có thể pull bất cứ project nào	-> 	login user jenkins -> Profile -> Access Token: tạo token with scope API (glpat-yxTGnBKM4XPAEYJ8WiUZ: add token vào jenkins)
				- Jenkins: 
					+ install plugin: 	Gitlab, BlueOcen (down log, UI hiện đại hơn)			- add domain gitlab
					+ Manage Jenkins:	-> System -> Gitlab:	set name - domain - add API token [Domain: Global  -  Kind: API token  -  Scope: Global/System  -  ID: jenkins-gitlab-user] -> Add -> Test Connection Success
					+ Save
				// 2.2. Tạo pipeline CI/CD
				- Jenkins: create Folder & Pipeline
					+ Folder:	(Dashboard -> New Item) tạo mỗi folder cho dự án -> chứa jobs của dự án đó
						- lab-server: folder Action-in-lab
					+ Pipeline: tạo pipeline cho dự án in folder Action-in-lab ( Dashboard -> Action-in-lab folder -> New Item -> Pipeline: name shoeshop) -> Config as below:
						- Config pipeline shoeshop:	(Full project name: Action-in-lab/shoeshop)
							- Discard old builds: 	Max build to keep - giữ lại số bản build latest = 10
							- Gitlab connection:
							- Build trigger: 		event push, merge, ...
							- Pipeline:				Pipeline script from SCM -> SCM: Git / Repo Url: http://gitlab.devops.tech/group/shoeshop.git / Credentials: new Jenkins [user: jenkins, pass: password]
							- Branches to build:	add multi branch
							- Jenkinsfile:			create file on git project
						- Save
						
					+ Token for user jenkins:		Account -> Security -> API token: add new token (nên tạo user riêng cho project)
				- Gitlab:
					+ add host for jenkins domain jenkins.devops.tech
					+ Allow Webhooks:	Admin Setting -> Network -> Outbound request:  Allow requests to the local network from webhooks and integrations -> Save
					+ Add Webhooks:		Project Setting -> Webhooks) add Webhooks from Jenkins info
						- URL: format [http://<user jenkins>:<token user jenkins>@<domain jenkins>/project/<path of project on jenkins>]	// http://user:token@jenkins.devops.tech/project/Action-in-lab/shoeshop
						- Add -> Test event: Http 200 = success
						
					+ Add Jenkinsfile for project: groovy syntax
						pipeline {
							agent {
								label 'lab-server-node-label'
							}
							environment {
								appUser = "shoeshop"
								appName = "shoe-ShoppingCart"
								appVersion = "0.0.1-SNAPSHOT"
								appType = "jar"
								processName = "${appUser}-${appVersion}.${appType}"
								folderDeploy = "/datas/${appUser}"
								buildScript = "mvn clean install -DskipTests=true"
								copyScript = "cp target/${processName} ${folderDeploy}"
								permsScript = "chown -R ${appUser}. ${folderDeploy}"
								killScript = "sudo kill -9 \$(pgrep -f ${processName})"
								deployScript = "sudo su ${appUser}; cd ${folderDeploy}; pwd; ls -l; whoami; java -jar ${processName} > nohup.out 2>&1 &"
							}
							stages {
								stage('build') {
									steps {
										sh(script: """ whoami; pwd; ls -la; ${buildScript} """, label: "show info")
									}
								}
								stage('deploy') {
									steps {
										///////////////////// Automatically deploy - CDeployment ////////////////////////////////////
									sh(script: """ ${copyScript} """, label: "copy jar file")
									sh(script: """ ${permsScript} """, label: "set permission")
									sh(script: """ ${killScript} """, label: "kill old processName")
									sh(script: """ ${deployScript} """, label: "deploy app")
									///////////////////// Automatically deploy - CDeployment ////////////////////////////////////
									
									///////////////////// Ask before deploy - CDelivery ///////////////////////////////////////
									script {
										try {
											timeout(time: 5, unit: 'MINUTES') {
												evn.userChoice = input message: "Do you want to deploy this?", parameters: [choice(name: 'deploy', choices: 'no\nyes', description: 'Choose "yes" to deploy')]
											}
											echo "Check choice: $env.userChoice"
											if (evn.userChoice == 'yes') {
												sh(script: """ ${copyScript} """, label: "copy jar file")
												sh(script: """ ${permsScript} """, label: "set permission")
												sh(script: """ ${killScript} """, label: "kill old processName")
												sh(script: """ ${deployScript} """, label: "deploy app")
											} else {
												echo "User do not confirm the deployment!"
											}
										} catch(Exception ex) {
											echo "Deploy Exception: $ex"
										}
									}
									///////////////////// Ask before deploy - CDelivery ///////////////////////////////////////
								}
							}
						}

		- Jenkins CI/CDelivery:
			+ make service to start jenkins-agent: 		nano /lib/systemd/system/jenkins-agent.service
					[Unit]
					Description=Jenkins Agent Service
					After=network.target								# run service sau khi network dc thiet lap xong
					
					[Service]
					Type=simple
					WorkingDirectory=/var/lib/jenkins
					ExecStart=/bin/bash -c 'java -jar agent.jar -url http://jenkins.devops.com:8080/ -secret @secret-file -name "lab-server-node" -webSocket -workDir "/var/lib/jenkins/"'		# command to run jenkins-agent
					User=jenkins
					Restart=always										# auto restart if it is stopped
					
					[Install]
					WantedBy=multi-user.target							# can run by multi-user
			
			+ CDelivery:
				- approved deploy:	ask for deploy
						pipeline {
							agent {
								label 'lab-server-node-label'
							}
							environment {
								..........
							}
							stages {
								stage('build') {
									...............
								}
								stage('deploy') {
									steps {
										script {
											try {
												timeout(time: 5, unit: 'MINUTES') {
													evn.userChoice = input message: "Do you want to deploy this?", parameters: [choice(name: 'deploy', choices: 'no\nyes', description: 'Choose "yes" to deploy')]
												}
												echo "Check choice: $env.userChoice"
												if (evn.userChoice == 'yes') {
													sh(script: """ ${copyScript} """, label: "copy jar file")
													sh(script: """ ${permsScript} """, label: "set permission")
													sh(script: """ ${killScript} """, label: "kill old processName")
													sh(script: """ ${deployScript} """, label: "deploy app")
												} else {
													echo "User do not confirm the deployment!"
												}
											} catch(Exception ex) {
												echo "Deploy Exception: $ex"
											}
										}
									}
								}
							}
						}
				
				- totaly manual deploy: for production environment
					// make selection for build
					+ create new folder - pipline for production: 	Action-in-prod	-> add pipeline shoeshop -> config as below: -> Save
						- Max of build: 10
						- Gitlab connection: This project is parameterized [Choice params: Name=server, Choices=lab-server/server1/server2 (~ jenkin node)]=select Server		[Choice params: Name=Action, Choices=start/stop/restart/update]=select Action
							+ install plugin:	Active Choice			// search: Active choice Jenkins			groovy script jenkins				node syntax jenkins
						- Pipeline: Pipeline script
					
					// Gitlab connection: using parameters with plugin: Active Choice
					+ steps:	typing script as below with option "Use Groovy Sandbox"typing script as below with option "Use Groovy Sandbox"
						- script select server						// Active choice parameters				// script: return ['lab-server-node', 'lab-server-node-name-1', 'lab-server-node-name-2'] - array
						- script select action						// Active choice parameters				// script: return ['start', 'stop', 'upcode', 'rollback] - array
						- string parameters							// for git commit hash to clone code
						- script rollback						// [create backup folder / run folder]		[backup=zip run folder -> copy .zip to backup folder]		[rollback=unzip file to run folder]
							+ detemine prev version:			// by prev commit hash -> clone src code cu -> search command: git lock
								- backup = zip					// Active choice reactive parameters, need libs: hudson.FilePath, jenkins.model.*
							+ jenkins can't auto approval script: using plugin  Permissive Script Security -> still see the numbers and lists in In-process Script Approval, but Jenkins will bypass it
									import jenkins.model.*
									import hudson.FilePath

									backupPath = "/datas/shoeshop/backups/"
									def node = Jenkins.getInstance().getNode(server)					// server = server-node-name [not label]
									def remoteDir = new FilePath(node.getChannel(), "${backupPath}")

									def files = remoteDir.list()
									def fileNames = files.collect {it.name}

									if (action == "rollback") return fileNames
									else return ['ver1', 'ver2']
						
						- pipeline script:					chekout-clone code/build/config/run
								appUser = "shoeshop"
								appName = "shoe-ShoppingCart"
								appVersion = "0.0.1-SNAPSHOT"
								appType = "jar"
								processName = "${appName}-${appVersion}.${appType}"
								folderDeploy = "/datas/${appUser}/run"
								folderBackup = "/datas/${appUser}/backups"
								folderMain = "/datas/${appUser}"
								buildScript = "mvn clean install -DskipTests=true"
								copyScript = "sudo cp target/${processName} ${folderDeploy}"
								permsScript = "sudo chown -R ${appUser}:${appUser} ${folderDeploy}"
								killScript = "sudo kill -9 \$(pgrep -f ${processName})"
								runScript = "sudo su ${appUser} -c 'cd ${folderDeploy}; pwd; ls -l; whoami; java -jar ${processName} > nohup.out 2>&1 &'"
								gitUrl = "http://gitlab.devops.com/shoeshopgroup/shoeshop.git"

								def getProcessId() {
									def pId = sh(returnStdout:true, script: """ pgrep -f ${processName} """, label: "get pId")
									// def pId = sh(returnStdout:true, script: """ ps -ef| grep ${processName}| grep -v grep| awk \'{print \$2}\' """, label: "get pId")
								}

								def startProcess() {
									stage('start-run-process') {
										sh(script: """ ${runScript} """, label: "run the project")
										echo "get PID start"
										sleep 10
										def pId = getProcessId()
										if ("${pId}" == "") {
											error("Can not start process")
										}
										echo("${appName} with server " + params.server + " started")
									}
								}

								def stopProcess() {
									stage('stop-process') {
										def pId = getProcessId()
										if (pId != "") sh(script: """ sudo kill -9 ${pId} """, label: "kill process")
										echo("${appName} with server " + params.server + " stopped")
									}
								}

								def upcodeProcess() {   // clone src code - build - config - run
									stage('checkout-clone') { // sha - tag - 
										if (params.hash == "") error("Require commit hash for upcode")
										checkout([$class: 'GitSCM', branches: [[ name: params.hash ]], userRemoteConfigs: [[ credentialsId: 'gitlab-user-account-jenkins', url: gitUrl ]]])		 // tool checkout = GitSCM; branch=branch of commit; where=credentials + url
									}
									stage('build') {
										sh(script: """ ${buildScript} """, label: "build the project")
									}
									
									stage('config') {
										sh(script: """ ${copyScript} """, label: "copy .jar file to deploy folfer")
										sh(script: """ ${permsScript} """, label: "assign project permission for user shoeshop")
									}
								}

								def backupProcess() {
									stage('backup') { // appName_yyyyddmm_hhmm_hashCommit.zip
										def timeStamp = new Date().format("yyyy-mm-dd_HH-mm")
										def zipFileName = "${appName}_${timeStamp}.zip"
										sh(script: """ sudo su ${appUser} -c "cd ${folderMain}; zip -jr ${folderBackup}/${zipFileName} ${folderDeploy}" """, label: "zip run folder for backup old version") // -r=folder; -j=latest subFolder in folderBackup=backups
									}
								}

								def rollbackProcess() {
									stage('rollback') {
										sh(script: """ sudo su ${appUser} -c "cd ${folderDeploy}; rm -rf *" """, label: "delete current version")
										sh(script: """ sudo su ${appUser} -c "cd ${folderBackup}; unzip ${params.rollback_version} -d ${folderDeploy}" """, label: "rollback verion - ${params.rollback_version}")
									}
								}

								node(params.server) {
									currentAction = params.action
									echo "action ${currentAction}"
									if (currentAction == "start") startProcess()
									if (currentAction == "stop") stopProcess()
									if (currentAction == "upcode") {
										backupProcess()
										stopProcess()
										currentBuild.description = "server " + params.server + " upcode with hash " + params.hash
										upcodeProcess()
										echo "${currentBuild.description}"
										startProcess()
									}
									if (currentAction == "rollback") {
										backupProcess()
										stopProcess()
										rollbackProcess()
										startProcess()
									}
								}
					+ Build with parameters: 
						- select server, select action, input commit hash
						- need approve libs in "Script Approval" if script import some libs
						- click "Build" button to start pipeline
						
		// 1. kết nối jenkins-server đến lab-server: 		jenkins Agent
		// 2. kết nối jenkins-server đến gitlab-server: 	plugin-gitlab & BlueOcen
	
	1.6. Monitoring
		- search logs from file: 
			+ tail -n 5000 logFile
			+ grep keyWord logFile
		
		- Monitoring: 						CPU/RAM/Storage usage, SQL command ngốn CPU/RAM -> optimize, số lượng connection có vượt ngưỡng hay ko, server khả dụng hay ko		-> thiết lập ngưỡng cảnh báo
		- Tools monitoring open source:		ILKStack, Romikius, KaFla, Zabbix, Loki, Datadoc, LazyHost, Splug, ...
		- Zabbix:
			+ template sẵn nhiều, ko cần biết chuyên sâu vẫn đảm bảo vận hành/cảnh báo tốt
			+ warning nhiều type: server lỗi, service lỗi, high cpu/ram/storage, mạng chậm, db chậm, ... với ít thông số cần tùy chỉnh
			+ tích hợp với nhiều nền tảng thông báo để thông báo kịp thời:  tele, slack, email
			+ Tích hợp cả chuông cảnh báo tùy theo mức độ nghiêm trọng: thiết lập riêng 1 màn hình + 1 loa cảnh báo cho zabbix
			
			+ nhược điểm ~ :	cần nhiều time & kinh nghiệm tìm hiểu thêm tính năng
				- biểu diễn các thông số dạng biểu đồ
				- lưu lại lịch sử cảnh báo những khi nào
				- làm sao để monitoring nhiệt độ, độ ẩm, server khác hay webservice bất kì
			
			+ install:
				+ zabbix server: 
					- zabbix backend:
					- zabbix database:	MySQL / PostgreSQL
					- zabbix frontend:	nginx / apache
						+ webserver: nginx, apache [httpd.service], tomcat
				+ zabbix agent: 
2. Jenkins:
	2.1.
	2.2.
	2.3.
	2.4.
	2.5.
	2.6. Managing Jenkins
		2.6.1.
		.....
		2.6.8. In-process Script Approval:
			+ allow users to execute Groovy scripts in Jenkins, which are provided by: Script Console / Jenkins Pipeline / Extended Email plugin / Groovy plugin ["Execute system Groovy script" step] / JobDSL plugin [v1.60+]
			+ This protection is provided by the Script Security plugin: 2 way
				 - Groovy Sandbox: 	defalut
				 - Script Approval: unsandboxed scripts or allow sandboxed scripts to execute additional methods
			
			+ Groovy sandbox:
				- 

//////  KUBERNETES  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
0. Kubernetes:
	- Ưu điểm:
		+ CI/CD project nhẹ nhàng hơn
		+ project đạt zero runtime mà ít tốn công, ít rủi ro nhất
	- Roadmap:
		+ Devops = Development + Operations: 2 cert cho developer & operator
		+ Kubernetes:	2 hướng 
			- Triển khai project trên Kubernetes:	back-front + db
			- Vận hành hạ tầng trên Kubernetes:   
	- Require resource:
		+ On-premise:	16GB Ram / 6 Core CPU / 80G Disk		// server cụm Kubernetes, server loadBalancer, DB
		+ Cloud:		Google Cloud plaform / AWS / ASURE
		
	- Kubernetes: K8s
		+ nền tảng open source (Google open 2014), mở rộng để quản lya các ứng dụng được đóng gói và các service, giúp thuận lợi cho cấu hình và tự động hóa việc triển khai các ứng dụng.
		+ Deploy project:
			- Older:	triển khai trực tiếp trên 1 máy chủ vật lý -> khó phân chia tài nguyên sử dụng nhiều/ít của các dự án trong 1 máy chủ -> khắc phục = cách chạy mỗi dự án trên 1 máy chủ -> tốn chi phí duy trì máy chủ, ko mở rộng đc quy mô
			- Old:		sử dụng máy ảo, triển khai mỗi dự án trên 1 máy chủ ảo -> tiêu tốn tài nguyên, khó tinh chỉnh cấu hình
			- New:		Container:	cấp tài nguyên tối thiểu cho mỗi container -> rành mạch & tối ưu hóa tài nguyên, nhưng: Backup, fix lỗi, tăng giảm tài nguyên khi lượng user tăng cao, quản lý giá trị quan trọng đều phải làm = tay -> rủi ro vì con người vận hành khác nhau
			- Now:		K8S: khắc phục hầu hết vấn đề, tự động backup, sửa lỗi, tăng giảm tài nguyên phù hợp, quản lý chuyên nghiệp và tường minh các giá trị = set lệnh [human] + mornitoring[K8S] để thực thi lệnh[K8S]
		
		+ Khi nào nên sử dụng:	4 yếu tố Hiệu quả / Minh bạch / Có khả năng vận hành / Tối ưu chi phí
			- dự án lớn, dự án chạy đường dài
			- dự án có nhu cầu cao Scaling
			- cần triển khai đa môi trường
			- Mô hình Microservices
			- cần khả năng tự hồi phục (Self-Healing)  - gitops
			
		+ Arichitect:
			- Nodes: 		list node
				+ Node:		// ~CRI
					+ pods: list pod
						- pod:			pod là đơn vị nhỏ nhất trong cụm K8S = Cluster, mỗi pod có 1/nhiều container				(pod = nhân viên, container=skill/task)
					+ kubelet:			nhận yc từ kube-api-server để thực thi các pod trên node									(trưởng phòng -> nhận task từ kube-api-server và giao/giám sát task cho nhân viên)
					+ kube-proxy:		thành phần network chạy trên mỗi node, cho phép các pod giao tiếp với nhau và với bên ngoài (coor - quan hệ công chúng / kết nối nhân nhân sự / nv giao hàng)
			
			- cloud-control-manager:	kết nối với cloud provide api và kube-api-server											(tổng giám đốc)
			- kube-api-server:			là 1 api để có 1 quy chuẩn chung để giao tiếp giữa ngoài vào trong cụm 						(on-premise thì ko có cloud -> kube-api-server chính là giám đốc luôn)
			- etcd:						csdl phân tán, nơi lưu trữ mọi cấu hình cụm K8S [tất cả các trạng thái của pod, node, resource] (kho lưu trữ / giấy tờ, sp)
			- scheduler:				phân phối pod đến các node trong cluster dựa trên các yc resource / policy / yc khác = thuật toán lập lịch để tối ưu workload = tìm ra node phù hợp nhất để đưa pod lên // deploy 1 pod lên 1 node = deploy dự án lên 1 server
			- controler manager:		quản lý các controller là những tiến trình giám sát trạng thái cluster và sửa chữa nếu cần [sửa: tạo ra 1 pod mới thay thế]
			
			+ Cluster architect:		cụm
				- kube-api-server  <---   Nodes [node: kube-api-server <--- kubelet ---> pod	 	/ 		kube-api-server <--- kube-proxy ---> pod]
				// Control-plane
				- kube-api-server  <---   etcd
				- kube-api-server  <---   scheduler [kube-scheduler]
				- kube-api-server  <---   controller manager [kube-control-manager]
				- kube-api-server  <--->  cloud-control-manager	---> [Cloud provider api - not in Cluster]
				
		+ Install K8S Cluster: 			Cloud/On-premise -> 40 cách cài đặt khác nhau -> chọn cách phù hợp		// how many way are there to install Kubernetes
			- Auto:		kops / RKE / kubespray		// 1 vài click là xong, install nhanh
							+ kubespray ko đảm bảo rằng có version mới nhất do bên t3 phát triển, phải đợi phiên bản mới nhất cập nhật thì spray mới cập nhật đc
							+ RKE (google):
			- Manual:	Kubeadm						// rành mạch từng bước, các command rất cụ thể -> khi có lỗi dễ debug và dễ nâng cấp lên ver mới nhất
				- K3S: phiên bản rút gọn của K8S
				- Cụm K8S với 3 server (3 node) là tối thiểu = 1 control-plane + 2 worker (2 nodes)		// control-plane = node master: mặc định ko deploy dự án lên đó -> ảnh hưởng đến các cv điều phối của master
				- startup / dự án nhỏ / dev env / staging env / demo: 3 node = 3 control-plane = 3 worker
							
		+ Install K8S Cluster: On-premise		[hiểu đc K8S có j, cần j / các mô hình K8S adapter / làm sao đề xuất 1 node lên làm master] 			https://www.fortaspen.com/install-kubernetes-containerd-ubuntu-linux-22-04/		
			- tạo 3 server: 2cpus, 3-4GB ram -> change IP, hostname -> add hosts for 3 server -> tạo snapshoot cho cả 3
			//////////////////////
			- tạo user devops -> add group sudo cho user devops để có quyền thực thi: 		adduser devops		->		usermod -aG sudo devops		-> su devops
			- update ubuntu cho cả 3:	sudo apt update -y && sudo apt upgrade -y
			- Deactivate swap: off swap do k8s yêu cầu, nếu ko thì ko kết nối tới api đc
				+ sudo swapoff -a		// off tạm thời	>< Vĩnh viễn: cat /etc/fstab	-> 	comment line: /swap.img		=  sudo sed -i '/swap.img/s/^/#/' /etc/fstab	// Kubernetes won’t work with ‘swap’ (using disk as an extension of memory) active
			- Linux Kernel Modules:			// tạo file k8s.conf để active 2 linux kernel module: overlay, br_netfilter		// list module: lsmod		// check module active: lsmod| grep overlay/br_netfilter
				+ sudo tee /etc/modules-load.d/k8s.conf <<EOF										
						overlay							
						br_netfilter
						EOF
					-> active module: sudo modprobe overlay br_netfilter
			- Update Kernel Networking Config:							// We need to set a few configuration parameters so that the Linux kernel correctly deals with bridged traffic.		-> test: sudo sysctl --system
				+ cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
				net.bridge.bridge-nf-call-iptables  = 1
				net.bridge.bridge-nf-call-ip6tables = 1
				net.ipv4.ip_forward                 = 1
				EOF
			
			//////////////
			- Install Kubernetes Software: by kubeadm	- There are three packages to be installed
				+ kubeadm – installation and admin tool
				+ kubelet – main Kubernetes linux service/daemon
				+ kubectl – command line tool for controlling a Kubenetes cluster
				
				# make sure you have the necessary tools
				sudo apt-get install -y apt-transport-https ca-certificates curl
				# download the keyring for validating the downloads
				sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
				# add the kubernetes.io repository to the local server’s list and trust the keyring
				echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
				# refresh local respository list
				sudo apt-get update
				# install kubelet kubeadm kubectl
				sudo apt-get install -y kubelet kubeadm kubectl
				# prevent automatic updates (which may upset versioning)
				sudo apt-mark hold kubelet kubeadm kubectl							// hold version of package, nếu ko hold thì khi update sẽ có package đc update hoặc ko, dẫn đến lệch version -> lỗi cả cụm
				
			- install container runtime: containderd của google [hoặc docker]:		sudo apt-get install -y containerd		// (Don’t use the “containerd.io” package used by Docker – this does not include the cri plugin necessary for working directly with Kubernetes. “ctr plugins ls” should include a plugin with ID “cri”.)
			/////////////////////////
			
			///////////// devopsedu.vn //////////// 	Thực hiện trên cả 3 servers
			Thêm hosts
				# vi /etc/hosts/
				192.168.1.111 k8s-master-1
				192.168.1.112 k8s-master-2
				192.168.1.113 k8s-master-3
			Cập nhật và nâng cấp hệ thống
				# sudo apt update -y && sudo apt upgrade -y
			Tạo user devops và chuyển sang user devops
				# adduser devops
				# su devops
				# sudo usermod -aG sudo devops
				# cd /home/devops
			Tắt swap
				# sudo swapoff -a
				# sudo sed -i '/swap.img/s/^/#/' /etc/fstab
			Cấu hình module kernel
				# vi /etc/modules-load.d/containerd.conf
			Nội dung sau:
				overlay
				br_netfilter
			Tải module kernel
				# sudo modprobe overlay
				# sudo modprobe br_netfilter
			Cấu hình hệ thống mạng
				# echo "net.bridge.bridge-nf-call-ip6tables = 1" | sudo tee -a /etc/sysctl.d/kubernetes.conf
				# echo "net.bridge.bridge-nf-call-iptables = 1" | sudo tee -a /etc/sysctl.d/kubernetes.conf
				# echo "net.ipv4.ip_forward = 1" | sudo tee -a /etc/sysctl.d/kubernetes.conf
			Áp dụng cấu hình sysctl
				# sudo sysctl --system
			Cài đặt các gói cần thiết và thêm kho Docker
				# sudo apt install -y curl gnupg2 software-properties-common apt-transport-https ca-certificates
				# sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmour -o /etc/apt/trusted.gpg.d/docker.gpg
				# sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
			Cài đặt containerd
				# sudo apt update -y
				# sudo apt install -y containerd.io
			Cấu hình containerd
				# containerd config default | sudo tee /etc/containerd/config.toml >/dev/null 2>&1
				# sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml
			Khởi động containerd
				# sudo systemctl restart containerd
				# sudo systemctl enable containerd
			Thêm kho lưu trữ Kubernetes
				# echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.32/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list
				# curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.32/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
			Cài đặt các gói Kubernetes
				# sudo apt update -y
				# sudo apt install -y kubelet kubeadm kubectl
				# sudo apt-mark hold kubelet kubeadm kubectl
			
			////////// Xem tiếp bài giảng để cài đặt K8s cluster phù hợp (xác định mô hình cụm cần cài đặt và reset cụm nếu cài không như mong muốn)
			Mô hình đầu tiên:  1 master 2 worker
				Thực hiện trên server k8s-master-1
					# sudo kubeadm init						-> các node khác join vào master: 	sudo kubeadm join 192.168.56.70:6443 --token your_token --discovery-token-ca-cert-hash your_sha --control-plane --certificate-key your_cert
					# mkdir -p $HOME/.kube
					# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
					# sudo chown $(id -u):$(id -g) $HOME/.kube/config
					# kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml		// cài network cho cụm
				Thực hiện join trên server k8s-master-2 và k8s master-3
					# sudo kubeadm join 192.168.56.70:6443 --token your_token --discovery-token-ca-cert-hash your_sha
					
			Mô hình thứ hai: 3 master (worker) – xem video bài giảng để hiểu
				Thực hiện trên server k8s-master-1
					# sudo kubeadm init --control-plane-endpoint "192.168.1.111:6443" --upload-certs
					# mkdir -p $HOME/.kube 
					# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 
					# sudo chown $(id -u):$(id -g) $HOME/.kube/config
					# kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml		// cài network cho cụm
				Thực hiện trên server k8s-master-2 và k8s-master-3
					# sudo kubeadm join 192.168.1.111:6443 --token your_token --discovery-token-ca-cert-hash your_sha --control-plane --certificate-key your_cert
					# mkdir -p $HOME/.kube 
					# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 
					# sudo chown $(id -u):$(id -g) $HOME/.kube/config
				//////// đến đây cả 3 node đều có role control-plane
				Set role worker cho 3 node:		chạy 3 lần cho 3 node, chạy trên node 1 (có init)
					# kubectl taint nodes k8s-master-1/2/3 node-role.kubernetes.io/control-plane:NoSchedule-
				
			Khối lệnh reset cụm khi đã khởi tạo cụm:	chạy trên tất cả các node / server
				# sudo kubeadm reset -f
				# sudo rm -rf /var/lib/etcd
				# sudo rm -rf /etc/kubernetes/manifests/*
			//////////////////////////////////
		
		+ Install K8S Cluster: On Cloud [Google Cloud Plaform - GCP - 300$ free for 3 month]
			- Login GCP -> Menu -> Kubernetes Engine -> Clusters: Create -> Standard (Tự quản lý):			// Auto: Google quản lý cluster
				+ Cluster basic:
					- Name:				đặt tên theo dự án & môi trường, có thể dùng tên cty và nên tạo 1 cụm to để triển khai các dự án ở trên các môi trường khác nhau
					- Location type:	nơi đặt cluster -> giá thay đổi theo location
					- Release Channel of GKE:  chọn channel phát hành cho các phiên bản k8s cho cluster = chiến lược để nâng cấp cụm k8s giúp cân bằng giữa các tính khả dụng của các năng mới và tính ổn định
						- Rapid:	 	luôn sd new feature GKE release nhưng có thể ko ổn định như các channel khác do mới
						- Regular:		balance tính năng mới vs tính ổn định, và đc cập nhật các tính năng mới có kiểm soát
						- Stable:		ưu tiên cho production, cần tính ổn định hơn là mới
						- Extended:		giữ nguyên 1 version trong 1 time dài, ngay cả khi version đó đã hết time hỗ trợ chuẩn, ko cập nhât cụm k8s lên version mới -> chỉ nên sd cho các cụm ít thay đổi và có độ ổn định cao, hoặc đặc thù ứng dụng & tools trên cụm đó
						- No channel:	not recommend -> có thể tắt tự động cập nhật -> có thể bị lỗi do ko đồng nhất phiên bản, quản lý khó khăn hơn và đội chi phí
				+ Fleet registration:	gom nhóm cụm và quản lý các cụm k8s theo nhóm -> multi-cluster: áp dụng policy đồng nhất cho từng nhóm, dễ quản lý và vận hành hơn
				+ default-pool:			
					- Name:
					- Compact placement:	các cụm đc để gần nhau -> data center
					- Queued ...:			sd tính năng xếp hàng để cung cấp các node trong pool linh hoạt hơn	 -> dựa trên nhu cầu và công suất tải của task -> cho phép tự động điều chỉnh tài nguyên khi khối lượng cv thay đổi
					- Size:					số lượng node
					- Automation:			
						+ Automatically upgrade ...:	tự động upgrade các node lên version mới nhất khi có sẵn theo version mới của control-plane, nhưng có thể gây lỗi [github-runner k8s bị lỗi die by line khi ci-cd trên k8s cloud]
						+ Auto repair:					tự động fix khi node gặp vấn đề như ko phản hồi, ... ko đảm bảo tính ổn định của cụm
					- Node pool upgrade strategy:		
						+ Surge upgrade:				tạo ra 1 node mới tương tự join vào cụm, rồi upgrade từng node
						+ Blue-green upgrade:			tạo nguyên 1 cụm mới giống cụm hiện tại và chuyển resource sang cụm mới						-> chi phí cao hơn
					- Nodes:							
						+ Image type:					chọn cấu hình server từng node ->  ubuntu with container
						+ Machine configuration:		chọn phần cứng cho từng node:	cpu, ram, gpu(VRAM) for ML/AI -> using as recommend
					- Networking:						recommend, cần biết / bao nhiêu, khoảng CIDR là j?
					- Security:							recommend, production cần kiểm soát chặt, access vào ra của bất cứ traffic nào
					- Metadata:							
						+ Kubernetes label:				key-value = env-development, nên gán nhãn rõ ràng cho từng cụm
						+ Node taint:					đánh dấu node để hạn chế việc gán port ko phù hợp -> quản lý và tối ưu hóa việc triển khai workload trên các node
				+ Cluster:
					- Backup plane:						enable ...
					- Feature:							default
				-> create
				
			+ View cluster vừa tạo -> Connected: google tụ động điền command kết nối -> Enter là vào đc k8s
		
1. Triển khai project thực tế:			full stack back-front + db -> ra cách làm
	1.1. Quy trình triển khai			// roadmap.sh		// search: kubernetes flow, 2 flow: architecture flow / deploy flow
		+ Traffic -> Ingress [domain1, domain2] -> Service [service1, service2] -> [ Node: [pod1, pod2], Node[pod11, pod12] ]
		+ File yaml:			// key: value				// k8s có support json nhưng ít dùng hơn yaml
			- Cú pháp đơn giản
			- Định dạng phong phú
			- Cấu trúc rõ ràng
			- cộng đồng lớn
			- syntax:
					key: value
					list:
						- element1
						- element2
					map:
						key1: value1
						key2: value2
					# comment
					listOfMap:
						- key1: value1
						  key2: value2
						- key3: value3
						  key4: value4
			- Keys:
				+ apiVersion: 	format=group:version	// 1 số resource: port, service, config map nằm trong nhóm cốt lõi của k8s, vì vậy chỉ cần có version mà ko cần có group
				+ kind:			khai báo các tài nguyên:	Pod/Service/Secret/ConfigMap/Ingress/Deployment/StatefulSet/DaemonSet/PersistentVolume/PersistentVolumeClaim
				+ metadata:		chứa thông tin liên quan đến resources:	name/labels/namespace/annotations
				+ spec:			định nghĩa thông tin chi tiết cấu hình của resource tùy theo kind: [pod: spec của container in pod], [Deployment: spec của pod/template/jdk]
				
		+ Namespace: chia nhóm node trong k8s để dễ quản lý và phân chia tài nguyên
			- 
2. Xây dựng công cụ dự án:				db, message, cache	-> dảm bảo data & tối ưu
3. Giám sát và quản trị Kubernetes:		monitoring dự án, hạ tầng server, uptime, backup & restore trên cụm Kubernetes
4. 
5.
6.
//////  KUBERNETES  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


https://www.baeldung.com/linux/virtualbox-ping-guest-machines

Windows 11 is not listing a bridged adapter for VirtualBox
Since I've ended up on this old topic from Windows 11 issues, I'm sure others also will, so I wanted to provide an up to date answer for those experiencing this on Windows 11.

This expands on this answer https://stackoverflow.com/a/47418596/349659 and its comments to be more easily digestible and relevant to Windows 11.

How to add a bridged adapter for Windows 11 and Virtualbox when none are showing
Open windows start button.
Search for: network.
Choose: View network connections via the control panel.
Right click your primary connection (for me it was just Ethernet since I'm on a wired connection).
Select: Properties.
Click: Install....
Select: Service.
Click: Add....
Click: Have Disk....
Click: Browse.
Navigate to the associated virtualbox install location for your given drive. 
For example mine was: C:\Program Files\Oracle\VirtualBox\drivers\network\netlwf\VBoxNetLwf.inf
Click: OK.
Select: VirtualBox NDIS6 Bridged Networking Driver.
Click: OK.
Select the bridged adapter in VirtualBox
You should now be able to restart VirtualBox, select bridged adapter for your network configuration for your virtual machine,
 and now names should populate in the Names dropdown; select your primary connection and you should be good to go now.
