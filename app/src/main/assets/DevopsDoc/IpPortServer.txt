///////////////////	Home ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Name						IP						Domain					Web/Port/Type
lab-server					192.168.55.10			server.devops.com		todolist:8080/Vuejs:nginx		shoeshop
git-db-registry-server		192.168.55.20			gitlab.devops.com		gitlab:80						database:3306				registry:5000
jenkins-server				192.168.55.30			jenkins.devops.com		jenkins:8080
///////////////////	Company	//////////////////////////////////////////////////////////////////
Name						IP						Domain					Web/Port/Type
lab-server					192.168.56.10			server.devops.com		todolist:2001/Vuejs:nginx			vision:3000/React:service			shoeshop:8090/Spring:
																			todolist:5555/Vuejs:docker			vision:4444/React:docker			shoeshop:7777-6666/Spring:docker
database-server				192.168.56.20:3306		database.devops.com
gitlab-server				192.168.56.30			gitlab.devops.com
registry-server				192.168.56.40:5000		registry.devops.com
jenkins						192.168.56.50			jenkins.devops.com
zabbix-server				192.168.56.60
desktop						192.168.56.100

k8s-70-server				192.168.56.70
k8s-80-server				192.168.56.80
k8s-90-server				192.168.56.90
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ssh ngocnm@192.168.1.
192.168.1.10 server.devops.com
192.168.1.20 gitlab.devops.com
192.168.1.30 jenkins.devops.com
192.168.56.60 dev-server
192.168.56.50 k8s-worker
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ssh ngocnm@192.168.56.
192.168.56.10 server.devops.com
192.168.56.20 database.devops.com
192.168.56.30 gitlab.devops.com
192.168.56.40 registry.devops.com
192.168.56.50 jenkins.devops.com

192.168.56.70 k8s-70-server
192.168.56.80 k8s-80-server
192.168.56.90 k8s-90-server
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1. Project: Envinroment: deployment - staging - prodction
2. Devops:
	- Setup Envinroment: 
		+ Servers: 					Linux, nginx, connection between servers [dev-server, gitlab-server, database-server], phân quyền user / security
		+ Setup Manage project: 	Gitlab, Jenkins, Travis, Circle
		+ CI/CD:					build -> test: 	pef, security, clean code, unit test, pin test ...
									run: 			deploy
3. Monitoring:
	- Internet:
		+ ping 8.8.8.8	 				= ping google.com
		+ telnet IP port				check connect to other server
		+ traceroute -T -p port IP	 	check port open or not (-T = tcp connection, -p = port)
	- Ram/Cpu usage:
		+ free -m	: ram usage
		+ df -h / 	: cpu usage
		+ top		: task manager
	- Check logs:
		+ tail -n 5000 logFile
		+ grep keyWord logFile
	- set time zone:
		+ sudo timedatectl set-timezone Asia/Ho_Chi_Minh			sudo dpkg-reconfigure tzdata
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
0. Virtualbox VM: 				
	+ shared folder:		E:\VMWare\SharedFolder
		- VM -> Setting -> SharedFolder -> New -> Select E:\VMWare\SharedFolder -> Mount point: /mnt/shared-folder or /home/user/shared-folder 	 & 		Select: Auto mount & Make Permanent
		- VM:		sudo mount -t vboxsf SharedFolder /mnt/shared-folder
		- Host: 	copy file to E:\VMWare\SharedFolder		-> ls /mnt/shared-folder
		- VM:		cp filePath /mnt/shared-folder			-> F5 E:\VMWare\SharedFolder
	+ shared folder VMWare:
		- VM setting -> ennable shared folder	-> 	add folder: D:\DevOps\VMWare\SharedFolder
		- Menu -> Edit -> Preferences: Enable all shared foldes by default
		- sudo apt-get install open-vm-tools
		- mkdir /mnt/shared-folder 		->		sudo /usr/bin/vmhgfs-fuse .host:/SharedFolder /mnt/shared-folder
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1. Project
	- install dependencies / tools for project (run & deploy)
	- set chmod, chowner for user & project
	- frontend:	Vue/React:	
		+ install packages: 		sudo apt install nodejs nginx npm -y
		+ install dependencies:		npm install
		+ deploy:												
			- build:				npm run build	 (folder: dist / build)						npm run start/server	
			- run:					
				+ webserver:		nginx		-> config: /etc/nginx/conf.d/xxx.conf			working: /usr/share/nginx/html/		-> apply: systemctl restart nginx / nginx -s reload
														server {
															listen 		8081; // port
															root 		/projects/todolist/dist/; // build folder
															index 		index.html;
															try_files	$uri $uri/ /index.html;
														}
				+ service:			systemctl	-> config: /lib/systemd/system/xxx.service		-> apply: systemctl daemon-reload /	systemctl restart vision (.service)	
														[Service]
														Type=simple
														User=vision
														Restart=on-failure
														WorkingDirectory=/projects/vision/
														ExecStart=npm run start -- --port=3000
	- backend:
		+ Java Spring:	
			- install java, maven, database:	apt install openjdk-17-jdk openjdk-17-jre maven -y [mariadb-server]
			- deploy:							build:	mvn install -DskipTest=true		/		run:	nohup java -jar target/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar 2>&1 &
			- config port:						server.port=8090								// project/src/main/resource/application.properties
/////////////////////////////////////////////////////////////////////////////////////
2. Database:	database-server
	- install: 		apt install mariadb-server -y
	- config:		/etc/mysql/mariadb.conf.d/xx_server.cnf		-> 		bind-address = 0.0.0.0		-> systemctl stop/restart mariadb
	- create db:	mysql -u root	-->		create database dbName; create user 'uName'@'%' indentified by 'pass'; 
											grant all privileges on dbName.* to 'uName'@'%'; flush privileges; exit
	- connect db:	mysql -h IP	-P 3306 -u uName -p 	-> enper password		-> use dbName; source db-file-path; // import db
	// gitlab-server
	- config db for project:		project/src/main/resource/application.properties
		- spring.datasource.url=jdbc:mysql://<address_server>:<port>/<database_name>//?useSSL=false
		- spring.datasource.username=<username>
		- spring.datasource.password=<password>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
3. Gitlab: gitlab-server
	- gitlab-ee:
		+ install: 		google
			- offline:		dpkg -i gitlab-ee_14.4.1-ee.0_amd64.deb
			- config: 		/etc/gitlab/gitlab.rb		-> external_url: gitlab domain	->		gitlab-ctl reconfigure
			- add hosts:	/etc/hosts					/windows hosts					-> 		add for gitlab-server & other server
		+ admin:		manage group/user/project
		+ project:	
			- config:	protected branch, runner, add variables, tags, pipeline, graph ...
			- create: 	branch/commit/merge request/
		
		+ gitlab secret: ...
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
4. Registry server: docker registry-server
	+ public: 			dockerhub
	+ harbor registry: 	harbor							-> manage users, docker [projects, images, and list tags of image] 		->		authenticate by 
	+ private registry: self authentication by openssl	(any user, any pass)
		- install openssl:				apt install openssl -y			mkdir -p /tools/docker/registry/certs & data
		- gen key by openssl:			cd /tools/docker/registry/		openssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key -subj "/CN=192.168.1.10" -addext "subjectAltName=DNS:192.168.1.10,IP:192.168.1.10" -x509 -days 3650 -out certs/domain.crt
		- install docker-compose: 		apt install docker-compose
		- write docker-compose.yml:		cd /tools/docker/registry/		nano docker-compose.yml		--> 	run: docker-compose up -d
			version: '3'
			services:
				registry:
					image: registry:2
					restart: always
					container_name: registry-server
					ports:
						- "5000:5000"
					volumes:
						- ./data:/var/lib/registry
						- ./certs:/certs
					environment:
						REGISTRY_HTTP_TLS_CERTIFICATE: certs/domain.crt
						REGISTRY_HTTP_TLS_KEY: certs/domain.key
				web:
					image: nginx:alpine
					ports:
						- "8000:80"
					volumes:
						- ./app:/usr/share/nginx/html
		- check:
			+ docker-compose ps							// list docker-compose running
			+ 192.168.56.10:5000/v2/_catalog:			// list images on registry									// registry-domain/v2/_catalog ~ registry.devops.com/v2/_catalog
			+ 192.168.56.10:5000/v2/image/tags/list:	// list tags of image on registry
		- *** copy cert to any client using registry & add hosts:	mkdir -p /etc/docker/certs.d/192.168.56.40:5000		----	cp 	/tools/docker/registry/certs/domain.crt /etc/docker/certs.d/192.168.56.40:5000/ca.crt
				cp /mnt/shared-folder/ca.crt /etc/docker/certs.d/192.168.56.40:5000/ca.crt		// for shared-folder
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
5. Jenkins server:
	+ install jenkins:		create file: /tools/jenkins/jenkins-install.sh				-> 		run: chmod +x ../jenkins-install.sh (cap quyen execute)				sh/bash ../jenkins-install.sh
		- add hosts & reverse proxy:	nginx 	& 	nano /etc/nginx/conf.d/jenkins.devops.com.conf	 ---	
				server { listen 80; server_name jenkins.devops.com; location / { proxy_pass http://jenkins.devops.com:8000; } }
	
	+ connect jenkins-server vs lab-server: 	by Jenkins Agent
		- lab-server:		install java version same jenkins: apt install openjdk-17-jdk / adduser jenkins	/ add jenkinsFolder: /var/lib/jenkins [clone code from gitlab / build / run]
							-> chown -R jenkins:jenkins /var/lib/jenkins	/ NOPASSWD: visudo for user jenkins
		- jenkins-server:	add Node [Number of executors 3/4 -- Remote root directory: jenkinsFolder from lab-server] [Add fixed port]	 -> save ->	show command to connect lab-server	-> node not run
		- lab-server:		su jenkins	-	cd /var/lib/jenkins		-> run commands with secret-file + nohup -> jenkinsFolder: save agent.jar / secret-file
							java -jar agent.jar -url http://jenkins.devops.com:8080/ -secret @secret-file -name "lab-server-node" -webSocket -workDir "/var/lib/jenkins/" > nohup.out 2>&1 &	-> node start running
							////
							make service for auto start jenkins-agent: 			nano /lib/systemd/system/jenkins-agent.service		-> 		systemctl daemon-reload		->		systemctl start jenkins-agent
								[Unit]
								Description=Jenkins Agent Service
								After=network.target								# run service sau khi network dc thiet lap xong
								[Service]
								Type=simple
								WorkingDirectory=/var/lib/jenkins
								ExecStart=/bin/bash -c 'java -jar agent.jar -url http://jenkins.devops.com:8080/ -secret @secret-file -name "lab-server-node" -webSocket -workDir "/var/lib/jenkins/"'		# command to run jenkins-agent
								User=jenkins
								Restart=always										# auto restart if it is stopped								
								[Install]
								WantedBy=multi-user.target							# can run by multi-user
	
	+ connect jenkins-server vs gitlab-server:	by plugin Gitlab, BlueOcen
		- gitlab-server:	create user jenkins - admin role		-> 	login by user jenkins		->		Profile: Access Token scope API
		- jenkins-server:	
			+ install plugin: 			[Gitlab, BlueOcen] -> System -> Gitlab: set name - domain - add API token [Domain: Global  -  Kind: API token  -  Scope: Global/System  -  ID: jenkins-gitlab-user] -> Add -> Test
			+ create token webhooks:	Account -> Security -> API token: add new token							// 1175600b85cccd7a9dbdf938e4587282a9 - used to add gitlab webhooks
	
	+ Script: 	
		- script có import lib thì lib đó cần đc approve trong "Script Approval", apply từng dòng 1 nên cần run script & F5 liên tục page:  http://jenkins.devops.com/manage/scriptApproval/ 		// nên test script trong "Script console" trước khi đưa vào pipeline
	
	+ check log:	By default logs should be made available in /var/log/jenkins/jenkins.log, unless customized in /etc/default/jenkins (for *.deb) or via /etc/sysconfig/jenkins (for */rpm)
		- java -jar /usr/share/java/jenkins.war			// fail
		- journalctl -u jenkins.service					// search key
		- config:	systemctl edit jenkins				// failed: file is not edited			//	[Service]	Environment="JENKINS_LOG=%L/jenkins/jenkins.log"
	
	+ config:		/etc/default/jenkins	-> PORT, LOGS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
6. Deploy servers: lab-server, sub-server, ...												nohub java -jar /run/shoeshop/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar > nohub.out 2>&1 &
	+ add hosts for gitlab-server, jenkins-server, lab-server, registry-server
	
	+ Gitlab CI/CD: 		using gitlab-runner
		- lab-server: install gitlab-runner
			+ online:	curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash	/	apt install gitlab-runner
			+ offline:	curl -LJO "https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-runner_amd64.deb"		/	 curl -LJO "https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-runner-helper-images.deb"
						dpkg -i gitlab-runner-helper-images.deb gitlab-runner_amd64.deb
			+ config:	/etc/gitlab-runner/config.toml		-> 		edit concurrent = 4
						visudo								->		gitlab-runner ALL=(ALL:ALL) NOPASSWD: /bin/cp*-chmod*-su shoeshop*			// for using other user to run CI/CD
			+ gitlab-runner register -> gitlab domain, token (on gitlab-server/project setting), runner name, executor=shell/docker/...
			+ gitlab-runner run --working-directory /home/gitlab-runner --config ../config.toml --service gitlab-runner --user gitlab-runner > nohup.out 2>&1 &	-> gitlab-runner list	// run = multiple >< run-single
			+ type: gitlab-runner-shell/docker		/		/home/gitlab-runner/xxx/project: [clone project from gitlab -> build -> run: copy *jar file to other folder "/datas/shoeshop/" & run]
		
		- gitlab-server:	develop for gitlab-runner-shell		/		staging for gitlab-runner-docker
			+ .gitlab-ci.yml: 	creater project/.gitlab-ci.yml	-> stages: [jobs] / variables: [vars] / stage: job / when: manual / script: [commands] / tag: runner-name / only: tags/branch
				- build stage: 	clone project from gitlab-server to lab-server with path: /home/gitlab-runner/builds/AZxtpzuE/0/shoeshopgroup/shoeshop 
								-> build folder: /target/ with user [gitlab-runner] on lab-server
				- deploy stage:	should use other user and folder for run/deploy project [user: shoeshop, folder: /datas/shoeshop/] -> cần copy file, cấp quyền rwx folder cho user
			+ CI with docker:	
				- usermod -aG docker gitlab-runner					// add group docker for user gitlab-runner, để gitlab có thể run docker
				- add variables: REGISTRY_URL / PROJECT / USER / PASSWORD								REGISTRY_URL = 192.168.56.40:5000		// protected variables only for protected branches
				- create project/Dockerfile:		-> 
					+ build:	[FROM build-alpine:ver as build]										[WORKDIR /app	COPY . .] 	[RUN build-command]	
					+ run:		[FROM alpine:ver	RUN run-envr-command]								[WORKDIR /run	COPY --from=build /target/image  /run/image]		
								[RUN adduser -D uName 		RUN chmod -R uName	 	User uName]			[EXPOSE containerPort]				[ENV xxx]
								[ENTRYPOINT run-command]												CMD ["command", "params", ""]		// run-command = java -jar /run/shoeshop/shoe-ShoppingCart-0.0.1-SNAPSHOT.jar
				- .gitlab-ci.yml:
					+ build:
						- before_script:	docker login registry-server -u user -p password
						- script:		 	docker build -t image . 	/		docker push image			// image format: domain/project/image:tag_commit
					+ run:
						- before_script:	docker login registry-server -u user -p password
						- script:		 	docker pull image	 		/		docker run --name containerName -dp serverPort:containerPort image		/ adduser & roles
											// docker run container: success = logs: Tomcat started on port(s): 8080 (http)		 						8080 = container port, neu da set port server truoc, Tomcat se start tren port do
					+ showlog:
						- script:			docker logs $DOCKER_CONTAINER
				- Notes:
					+ voi docker: 	connect toi database nen dung IP, dung domain co the bi loi "java.net.UnknownHostException: database.devops.com: Name does not resolve"
									docker run da co config -dp (run in background) roi nen trong Dockerfile ko can run backgroud nua (nohup)
	
	+ Jenkins CI/CDeployment:	need Jenkinsfile in project src code
		- lab-server: 		if node/jenkins-agent is not running: 	cd /var/lib/jenkins -> su jenkins -> java -jar agent.jar -url http://jenkins.devops.com:8080/ -secret @secret-file -name "lab-server-node" -webSocket -workDir "/var/lib/jenkins/" > nohup.out 2>&1 &	-> node start running
							-> make service for auto start jenkins-agent: 			nano /lib/systemd/system/jenkins-agent.service		-> 		systemctl daemon-reload		->		systemctl start jenkins-agent

		- jenkins-server:	create Folder & Pipeline of Folder & create token for user jenkins (nên tạo user riêng cho project - ngocnm, token dung tren gitlab)
			+ Folder:		Dashboard -> New Item -> Action-in-lab-server [Type: Folder]
			+ Pipeline:		Dashboard -> Action-in-lab-server -> New Item -> Pipeline: name shoeshop	
							-> config:	[Discard old builds: Max build to keep / Gitlab connection: gitlab-server / Build trigger: Events push-merge / Pipeline: Pipeline script from SCM [SCM: Git / Script Path: Jenkinsfile] ]
							-> config:  -> SCM: Git [Repo Url: http://gitlab.devops.tech/group/shoeshop.git  / Credentials: new Jenkins [user-gitlab: jenkins, pass: password / Branches to build: add branches ]
			+ Token:		Account -> Security -> API token: add new token							// 1175600b85cccd7a9dbdf938e4587282a9 - used to add gitlab webhooks
		
		- gitlab-server:	
			+ Allow Webhooks:	Admin Setting -> Network -> Outbound request:  Allow requests to the local network from webhooks and integrations -> Save
			+ Add Webhooks:	Project Setting -> Webhooks: [URL:  http://<user jenkins>:<token webhooks user jenkins>@<domain jenkins>/project/<path of project on jenkins>]	// http://user:token@jenkins.devops.com/project/Action-in-lab/shoeshop
			+ Add Jenkinsfile for project: groovy syntax
					pipeline {
						agent { label 'lab-server-node-label'}
						environment { appUser = "shoeshop"	/ appName / appversion / appType / processName / folderDeploy / folderBackup / folderMain / buildScript / copyScript / permsScript / killScript / runScript / ... }
						stages {
							stage('job-action') {
								steps {
									sh(script: """ whoami; pwd; ls -la; ${buildScript} """, label: "show info")
									script {
										try {
											if (evn.userChoice == 'yes') { sh(script: """ ${deployScript} """, label: "deploy app") } else { echo "xxx"}
										} catch (Exception ex) { echo "Deploy Exception: $ex" }
									}
								}
							}
							stage('job-n') {} ....
						}
					}
			+ CI with Docker:
				- lab-server: 		usermod -aG docker jenkins
				- jenkins-server:	add variables [REGISTRY_URL, REGISTRY_PROJECT, REGISTRY_USER, REGISTRY_PASS]
				- gitlab-server:	
					+ Dockerfile:	same above
					+ Jenkinsfile:
							
		- lab-server: Running on lab-server-node in /var/lib/jenkins/workspace/Action-in-lab-server/shoeshop
	
	+ Jenkins CI/CDelivery: 	totaly manual for prod environment
		- lab-server: 		run jenkins-agent by service as CI/CDeployment
		- gitlab-server:	not need allow Webhooks & Jenkinsfile as CI/CDeployment					// webhooks need declare working folder like: Action-in-lab-server/shoeshop and need Jenkinsfile in project src code
		- jenkins-server:	typing scripts as below with option "Use Groovy Sandbox"
			+ Create new folder for prod:	Dashboard -> New Item -> Action-in-prod [Type: Folder]
			+ Create pipeline for prod:		Dashboard -> Action-in-prod  -> New Item -> shoeshop [Type: Pipeline]	
				-> config: [Discard old builds: Max # of builds to keep / GitLab Connection: This project is parameterized -> add params scripts / Pipeline: Pipeline script ] -> Branches to build: branch is added by commit hash in step checkout src code from commit hash in Pipeline script
				- script select server						// Active choice parameters					// name: server				script: return ['lab-server-node', 'lab-server-node-name-1', 'lab-server-node-name-2'] - array
				- script select action						// Active choice parameters					// name: action				script: return ['start', 'stop', 'upcode', 'rollback] - array
				- string parameters							// for git commit hash to clone code		// name: hash
				- script rollback							// Active choice Reactive parameters		// name: rollback_version	script: [create backup folder / run folder]		[backup=zip run folder -> copy .zip to backup folder]	[rollback=unzip file to run folder]
			+ pipeline scripts:		params.[server/hash/action/rollback_version]				-> get value from params scripts
					appUser = "shoeshop"	/ appName / appversion / appType / processName / folderDeploy / folderBackup / folderMain / buildScript / copyScript / permsScript / killScript / runScript / ... 		// declare variables
					
					def methodName() {		// def startProcess()		def stopProcess()		def upcodeProcess()		def backupProcess()		def rollbackProcess()
						def pId = sh(returnStdout:true, script: """ pgrep -f ${processName} """, label: "get pId")
						stage('jobName') { if (pId == "") {sh(script: """ sudo kill -9 ${pId} """, label: "kill process"} else { echo "pId null" } ... }
						stage('jobName-2') {} ....
					}
					
					node(params.server) { 	// get correct node for each lab-server by server-node-name, not using node label
						currentAction = params.action
						if (params.action == 'rollback') {
							backupProcess()
							stopProcess()
							rollbackProcess()
							startProcess()
						}
						....
					}
		- lab-server: Running on lab-server-node in /var/lib/jenkins/workspace/Action-in-prod/shoeshop
	
	** Deploy result:
		+ Gitlab CI/CD: auto/manual by [when:manual/always 		only: -tags]
			- normal:			server.port=8888													http://192.168.56.10:8888					develop					// server.port=8888 in application.properties
			- docker:			server.port=9999				container.port=8080					http://192.168.56.10:9999					staging					// -dp 9000:8081
		+ Jenkins CI/CD:
			// auto: 	CDeployment
			- normal:			server.port=8000													http://192.168.56.10:8000					main					// server.port=8000 in application.properties
			- docker: 			server.port=9000				container.port=8081					http://192.168.56.10:9000					docker_deployment		// -dp 9000:8081
			// manual:	CDelivery
			- prod:				server.port=7000													http://192.168.56.10:7000					production				// server.port=7000 in application.properties
			- prod_docker:		server.port=6000				container.port=8082					http://192.168.56.10:6000					prod_docker				// -dp 9000:8082

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
7. Docker: on lab-server
	- install: apt install docker-ce									sh install-docker.sh
	- docker  login url / pull domain/project/image:tag / 				start containerName / stop / rm / rmi / logs / ps / push domani/project/image:tag
	- docker build -t domani/project/image:tag -f Dockerfile			-> build image
	- docker run --name name -dp 8080:80 -it image:tag					// 8080:80 = server-port:container-port
	
	- Dockerfile:	create new Dockerfile in ../project/
		+ Build:	FROM build-alpine:ver as build			WORKDIR /app							COPY . .							RUN cmd_build
		+ Run:		FROM run-alpine:ver						WORKDIR /run		RUN cmd_user		COPY --from=build /src /target		Run	cmd_run				ENTRYPOINT cmd_run
		+ EVN, EXPOSE, USER
	- docker-compose: 	docker-compose up -d docker-compose.yml			docker-compose ps
	
	- Docker component:
		+ Docker volume
		+ Docker compose
		+ Docker network
		
	- docker system prune: clear stop container / all network not using / dangling images / unused build cache
	
	- Tip security / optimize:
		+ non root user:				-> for security
		+ chọn base image phù hợp:		->
			- đúng version /Java 8 		-> nên cài maven java 8 để build & run: tối ưu dung lượng docker image build ra & hạn chế tools ko cần thiết làm tăng size
			- ubuntu/cenos				-> nên chọn image đc build sẵn dựa trên alpine vì nhẹ và tối ưu - hoặc image slime
			- base image uy tín			-> nên chọn : offical / verified / sponsored
			- tool quét image			-> check lỗ hổng
			
			- build: clean cached
		+ use Multiple stage: 			-> giảm size docker image cuối cùng đc build ra
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
8. Monitoring
	+ Zabbix
//////  KUBERNETES  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
9. Kubernetes
	9.1. Component:
		+ Cluster:		[master nodes - worker nodes]											// nhiều node, 1 master - n worker 	><	n master - n worker
			- Node:		[ ns1: [pod1.1, pod1.2, ...] 	ns2[pod2.1 pod2.2] 	... ]				// ns = name space
			- Master node:
				+ namespace:	
					- default, kube-system, kube-public, kube-node-lease						// when create node done: kubeadm init --address_server 192.168.56.70
					- cattle-system																// when import k8s to rancher
				// Pods
				+ Pod:	[1container		volumes]												// user pod
				+ etcd																			// pod in ns kube-system		name: etcd-k8s-70-master
				+ kube-apiserver																// pod in ns kube-system		name: kube-apiserver-k8s-70-master
				+ kube-scheduler																// pod in ns kube-system		name: kube-scheduler-k8s-70-master
				+ kube-controller-manager														// pod in ns kube-system		name: kube-controller-manager-k8s-70-master
				+ kube-cloud-manager															// pod in ns kube-system				
				// dns
				+ coredns-xxxx-yyy																// pod in ns cattle-system
				
				// Network
				+ calico-node-xxxx																// pod in ns kube-system		bao nhiêu node trong cluster thì có bấy nhiêu pod calico
				+ kube-proxy-xxxx																// pod in ns kube-system		bao nhiêu node trong cluster thì có bấy nhiêu pod proxy
				+ calico-kube-controllers-xxx													// pod in ns kube-system
				// Rancher
				+ cattle-cluster-agent-xxx														// pod in ns cattle-system		rancher agent -> need pull image rancher:v2.9.2 -> maybe got ImagePullBackOff error
				+ rancher-webhook
				+ rancher-provisioning-capi
			- Worker node:
				+ Pod
				+ kubelet
				+ kube-proxy
	9.2. Command
		+ kubeadm:
		+ kubectl:
			- kubectl logs car-serv-pod -n car-serv-ns
			- kubectl get events --all-namespaces  --sort-by='.metadata.creationTimestamp'
			- kubectl get events pod car-serv-pod -n car-serv-ns
			- kubectl describe pod car-serv-pod -n car-serv-ns
		+ kubelet:
	9.3. Fix error
		+ init k8s in master node:				- node is not ready	-> apply calico.yaml		- init wrong node ip -> init kem ip & set ip for each node in: 
		+ worker node joined to master node:	- node is not ready	-> apply calico.yaml		
		+ import k8s to rancher:				- cluster still pending	-> agent got error		- ImagePullBackOff / ContainerCreating
		+ Created new pod:						- pod still ContainerCreating -> 				// kubectl get events --all-namespaces  --sort-by='.metadata.creationTimestamp'		
			- Failed to pull image "elroydevops/car-serv:latest" / ImagePullBackOff / ContainerCreating / ErrImagePull: by cert error /  tls: failed to verify certificate: x509: certificate signed by unknown authority
			- Failed to create pod sandbox: rpc error 
			- Fix cert:
				+ 1. Copy *cert, *.key  in /etc/kubernets/pki/ to /usr/local/share/ca-certificates/		-> sudo update-ca-certificates
				+ 2. Systemctl restart containerd
			- Fix pulling image failed:
				+ 
				
		+ using privare registry:
			// 1. create secret for single privare registry
			- kubectl create secret docker-registry dockersecret-name --docker-server=192.168.56.40:5000 --docker-username=ngocnm --docker-password=admin 		// --docker-email=<your-email>
					containers:		// pod.yaml
					- name: ...
					imagePullSecrets:
					- name: dockersecret-name
				+ kubectl get secret dockersecret-name --output=yaml				kubectl describe secret dockersecret-name			kubectl edit/delete secrets <secret-name>
				+ kubectl get secret dockersecret-name --output="jsonpath={.data.\.dockerconfigjson}" | base64 --decode	 // {"auths":{"192.168.56.40:5000":{"username":"ngocnm","password":"admin","auth":"bmdvY25tOmFkbWlu"}}}
				// Add image pull secret to service account
				- kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "dockersecret-name"}]}'			// ~ kubectl edit serviceaccount/default
			// 2. Adding insecure registry in containerd
			- sudo nano /etc/containerd/config.toml
					[plugins."io.containerd.grpc.v1.cri".registry.configs]
					  [plugins."io.containerd.grpc.v1.cri".registry.configs."192.168.56.40:5000"]
						[plugins."io.containerd.grpc.v1.cri".registry.configs."192.168.56.40:5000".tls]
						  ca_file = ""
						  cert_file = ""
						  insecure_skip_verify = true
						  key_file = ""

					[plugins."io.containerd.grpc.v1.cri".registry.mirrors]	
					  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."192.168.56.40:5000"]
						endpoint = ["https://192.168.56.40:5000"]
			
			- sudo systemctl restart containerd
			- crictl -r unix:///var/run/containerd/containerd.sock 192.168.56.40:5000/			// test
			
			// 3. Specifying ImagePullSecrets on a Pod.
			- edit rancger-import.yaml:	image: 192.168.56.40:5000/rancher/rancher-agent:v2.9.2 			// from:	curl --insecure -sfL https://192.168.56.100/v3/import/2ddvphht4x77pt89kjcj6gh5766xt622c8lkxm58b5zssm8c7bfdvl_c-m-ggg7x598.yaml
			// check secret on worker node
			- kubectl -n kube-system exec -it etcd-k8s-70-master ls -l /etc/kubernetes/pki/etcd
			
			// 4. add insecure registry for docker on rancher server
			- nano /etc/docker/daemon.json
				{
				  "insecure-registries": ["192.168.56.40::5000"]
				}
			- systemctl restart docker
		
		// Rancher	
		+ Failed to install system chart rancher-provisioning-capi: pod cattle-system/helm-operation-trb86 failed, watch closed
		+ Failed to install system chart rancher-webhook: pod cattle-system/helm-operation-gzk49 failed, watch closed
		+ Internal error occurred: failed calling webhook "rancher.cattle.io.clusters.management.cattle.io": no endpoints available for service "rancher-webhook"
		//////////		kubectl  --namespace kube-system get configmap kubeadm-config -o yaml
		"--cluster-cidr=192.168.0.0/16"
		 networking:
		  dnsDomain: cluster.local
		  podSubnet: 192.168.0.0/16
		  serviceSubnet: 10.96.0.0/12
		
		+ rancher-webhooks: expiration cert
			- kubectl get validatingwebhookconfiguration rancher.cattle.io -o yaml > vwc-rancher.cattle.io.yaml
			- kubectl get mutatingwebhookconfiguration rancher.cattle.io -o yaml > mwc-rancher.cattle.io.yaml
			- kubectl delete validatingwebhookconfiguration rancher.cattle.io
			- kubectl delete mutatingwebhookconfiguration rancher.cattle.io
			
			- kubectl apply -f vwc-rancher.cattle.io.yaml
			- kubectl apply -f mwc-rancher.cattle.io.yaml
		+ 
		// cert
		+ sudo dpkg-reconfigure ca-certificates
		openssl x509 -inform DER -in certificate.cer -out certificate.crt
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CẤU TRÚC POD.YAML TRONG KUBERNETES

appversion: v1 					→ LOẠI API CỦA TÀI NGUYÊN (

kind: pod 						→ LOẠI TÀI NGUYÊN (POD)

metadata:
	name: techops-pod 			→ Tên duy nhất của Pod
	abels: 						→ Nhãn để tổ chức và chọn Podapp: techops → Nhãn ứng dụng, hữu ích cho bộ chọn (selectors)
		tier: backend 			→ Xác định lớp ứng dụng

spec:
	containers: 				→ CONTAINER(S) CHẠY TRONG POD NÀY
	- name: techops-container 	→ Tên của container
	  image: nginx:1.23 		→ Docker image cho container
	  ports:
	  - containerPort: 80 		→ Cổng mà container mở nội bộ
	  env:
	  - name: ENV
	    value: production 		→ Biến môi trường để cấu hình
	  volumeMounts: 			→ CÁC VOLUMES ĐƯỢC GẮN VÀO TRONG CONTAINER
	  - name: config-volume 	→ Volume được định nghĩa trong phần “volumes”
		mountPath: /usr/share/nginx/html 	→ Điểm gắn kết (mount point) bên trong container

	volumes:
	- name: config-volume 		→ Tên của volume
	  configMap:
	    name: techops-config	→ Sử dụng ConfigMap làm nguồn và tham chiếu đến ConfigMap có tên “techops-config”
	  
	RESTARTPOLICY: ALWAYS 		→ CHÍNH SÁCH KHỞI ĐỘNG LẠI POD (ALWAYS, ONFAILURE HOẶC NEVER)

	NODESELECTOR: 				→ LỊCH TRÌNH (SCHEDULE) POD TRÊN CÁC NODE CỤ THỂ
	  disktype: ssd 			→ Chỉ chạy trên các node có nhãn “disktype=ssd”

	TOLERATIONS: 				→ CHO PHÉP LÊN LỊCH TRÊN CÁC NODE BỊ "TAINT"
	- key: "special-taint" 		→ Khóa taint cần chấp nhận
	  operator: "Equal" 		→ Điều kiện khớp chính xác
	  value: "true" 			→ Giá trị cần khớp
	  effect: "NoExecute" 		→ Tác động: Không lên lịch (NoSchedule) hoặc đuổi khỏi node (NoExecute)

	SECURITYCONTEXT: 			→ THIẾT LẬP BẢO MẬT Ở CẤP ĐỘ POD	
	  runAsUser: 1000 			→ Chạy container dưới user ID này
	  runAsGroup: 3000 			→ Chạy container dưới group ID này
	  fsGroup: 2000 			→ Nhóm sở hữu volumes đã gắn kết

	INITCONTAINERS: 			→ CHẠY TRƯỚC KHI CONTAINER CHÍNH CHẠY
	- name: init-techops 		→ Tên container khởi tạo
	  image: busybox 			→ Image của container khởi tạo
	  command: ["sh", "-c", "echo Init; sleep 5"] 	→ Câu lệnh khởi tạo
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Hệ sinh thái gần hoàn chỉnh:
	- 1. kiali
	- 2. bookInfo - bookStore
	- 3. rancher
	- 4. grafana - istio
	- 5. argocd
	
Cheat Sheet: Hệ Thống Thiết Kế (System Design)
System  design là quá trình xây dựng các ứng dụng có thể đáp ứng nhu cầu thực  tế với khả năng mở rộng, hiệu suất cao và bảo mật tốt. 
Dưới đây là những thành phần cốt lõi bạn cần nắm rõ khi thiết kế hệ thống.
📌 Mạng & Kết Nối (Networking)
	DNS (Domain Name System): Hệ thống phân giải tên miền (resolvers, nameservers, records)
	Load Balancers: Cân bằng tải ở Layer 4, Layer 7 (phần cứng, phần mềm)
	CDNs (Content Delivery Networks): Mạng phân phối nội dung (caching, edge servers)
	Proxies: Proxy chuyển tiếp, proxy ngược, proxy ẩn danh
	VPNs (Virtual Private Networks): Mạng riêng ảo, giao thức đường hầm
	Firewalls: Tường lửa (lọc gói tin, kiểm tra trạng thái)
	NAT (Network Address Translation): Biên dịch địa chỉ mạng
	Gateways: Kết nối các mạng khác nhau
	Routers: Định tuyến lưu lượng giữa các mạng
📌 Lưu Trữ (Storage)
	Databases: SQL, NoSQL (key-value, document, columnar, graph), NewSQL
	Object Storage: Amazon S3, Google Cloud Storage, Azure Blob Storage
	Block Storage: NAS (Network-attached storage), SAN (Storage area networks)
	File Systems: Hệ thống file phân tán (HDFS, Ceph), NFS (Network File System)
	Caching: Redis, Memcached, Varnish, CDN edge caches
📌 Xử Lý (Compute)
	Servers: Máy chủ vật lý (bare metal), máy ảo (VMs)
	Containers: Docker, Kubernetes, container orchestration
	Serverless: AWS Lambda, Azure Functions, Google Cloud Functions
	FaaS (Function-as-a-Service): Dịch vụ serverless dành cho chức năng nhỏ
	PaaS (Platform-as-a-Service): Nền tảng điện toán đám mây
📌 Giao Tiếp (Communication)
	APIs: REST, GraphQL, SOAP, gRPC
	Message Queues: RabbitMQ, Kafka, ActiveMQ, Amazon SQS
	WebSockets: Giao tiếp thời gian thực, full-duplex
	RPC (Remote Procedure Call): XML-RPC, JSON-RPC
	Pub/Sub (Publish-Subscribe): Mô hình giao tiếp theo kiểu đăng ký - xuất bản
	Service Mesh: Istio, Linkerd (quản lý giao tiếp giữa microservices)
📌 Kiến Trúc Hệ Thống (Architectural Patterns)
	Microservices: Thiết kế hướng domain (DDD), service discovery, API gateways
	Monolithic: Kiến trúc nguyên khối, MVC, MVP
	Event-driven: Event sourcing, CQRS
	Serverless: FaaS, BaaS (Backend-as-a-Service)
📌 Khả Năng Mở Rộng & Độ Tin Cậy (Scalability & Reliability)
	Horizontal Scaling: Mở rộng theo chiều ngang (thêm máy chủ, auto-scaling)
	Vertical Scaling: Mở rộng theo chiều dọc (nâng cấp tài nguyên máy chủ)
	Replication: Master-slave, master-master
	Sharding: Chia nhỏ dữ liệu để tăng hiệu suất
	Redundancy: Dự phòng nhiều máy chủ, cơ chế failover
	Fault Tolerance: Cơ chế giảm thiểu lỗi (circuit breakers, graceful degradation)
	Disaster Recovery: Sao lưu, nhân bản, phân tán địa lý
📌 Bảo Mật (Security)
	Authentication: Xác thực (MFA, SSO, OAuth, OpenID Connect)
	Authorization: Phân quyền (RBAC - Role-based access control)
	Encryption: Mã hóa đối xứng, bất đối xứng, băm dữ liệu
	Security Protocols: TLS/SSL, HTTPS, SSH
	Web Application Firewalls: Bảo vệ trước các cuộc tấn công web
	Intrusion Detection Systems: Hệ thống phát hiện xâm nhập
📌 Quan Sát & Giám Sát (Observability)
	Monitoring: Giám sát (Prometheus, Grafana, Datadog, New Relic)
	Logging: Ghi log (ELK Stack - Elasticsearch, Logstash, Kibana, Splunk)
	Tracing: Theo dõi truy vết hệ thống (Jaeger, Zipkin)
	Metrics: Chỉ số đo lường (counters, gauges, histograms, summaries)
Cre: Mayank Ahuja
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
No one really spelled out how to fix this.
Here is what I did

My env:

Private docker registry on separate host. No password, using port 443
Private openssl CA.
Generate certs for each node (workers and masters). need public key, private key (unencrypted), and your root ca's public key (Openssl CA public key). I created a Subject Alternative Name (SAN) value for short hostname, FQDN, and IP address for each.
On each node create /etc/docker/certs.d/ (If it does not exist create it)
cd /etc/docker/certs.d/, create a directory in here that uses the SAME EXACT name used when you communicate with the registry in your manifest. So if you are referecing "docker-reg.company.domain" directory must say that. Or if you use "docker-reg.company.domain:443", need to make the directory name include the port. Must be exact as you reference in your mainfest.
Copy your RootCA, public key, and private key to this directory. They must be this name structure.
root ca = ca.crt
public key = client.cert
private key = client.key
Copy the root ca public key also to the cert store for the OS
Debian / Ubuntu
cp certs/domain.crt /usr/local/share/ca-certificates/myregistrydomain.com.crt
update-ca-certificates
Rhel / Centos
cp certs/domain.crt /etc/pki/ca-trust/source/anchors/myregistrydomain.com.crt
update-ca-trust

Test to make sure you can pull directly from the node with docker pull docker-reg.company.domain:443/my-image:latest (Or however you have it in your manifest, must be exact)
If all this is done correctly try doing a deployment with kubectl again. Be careful of namespaces.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
wget https://letsencrypt.org/certs/staging/letsencrypt-stg-int-r3.pem
wget https://letsencrypt.org/certs/staging/letsencrypt-stg-root-x1.pem

echo “Creating secret with let’s encrypt certs for rancher agent pod”
kubectl -n cattle-system create configmap ca-pemstore --from-file=letsencrypt-stg-root-x1.pem --from-file=letsencrypt-stg-int-r3.pem

echo “### patching rancher agent deployment…”
echo “### adding volume from configmap with let’s encrypt certs”
kubectl -n cattle-system get deployment cattle-cluster-agent -o json | jq ‘.spec.template.spec.volumes += [{“name”: “ca-pemstore”, configMap: {“name”: “ca-pemstore”} }]’ | kubectl replace -f -
sleep 1
echo “### Mounting volume with cert”
kubectl -n cattle-system get deployment cattle-cluster-agent -o json | jq ‘.spec.template.spec.containers[0].volumeMounts += [{“name”: “ca-pemstore”,“mountPath”: “/usr/local/share/ca-certificates/letsencrypt-stg-root-x1.crt”,“subPath”: “letsencrypt-stg-root-x1.pem”,“readOnly”: false}]’ | kubectl replace -f -
sleep 1
echo “### Adding postStart action to update system wide certificates”
kubectl -n cattle-system get deployment cattle-cluster-agent -o json | jq ‘.spec.template.spec.containers[0].lifecycle.postStart.exec.command = [ “/usr/sbin/update-ca-certificates”]’ | kubectl replace -f -
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
- Mô hình CI/CD:
	- TCB:
		+ Team: 		Sec - Vault			Ops - System		 Dev - Code
		+ Tool CI/CD:	jenkins - ansible
		+ Repo:			gitlab
		+ 1 tài khoản đặc quyền với full quyền tác động lên server, tkdq nhập use/path lên vault path, pass chia 2 nửa, sec gõ 1 nửa, ops gõ 1 nửa, sau khi nhập xong thì sec/ops chỉ biết là có cái path đó, ko biết pass là j.
		+ Dev code & commit trên repo dev -> sau 30'-1h repo dev đc sync đến repo prod, ops cũng viết pipeline để cicd cho app và commit như vậy.
		+ trong pipeline, ops define url vault, path vault, trong jenkins ops define credential vault -> đến ngày golive thì chạy
		
		+ 

- gitops: sử dụng kết hợp với Vault, ko lưu secret trong git.
- kyverno: xử lý phân quyền
- Vault: quản lý secret tập trung, edit/update secret -> ko có quyền vào Vault thì ko xem đc
	+ ks8 load secret by Agent -> phân quyền xem secret
	+ gitlab: save path of secret on Vault, ko đc khai báo secret trực tiếp
	
	+ nếu k sử dụng Vault, khi agent inject secret vào pod thì secret sẽ là env var/file, bất cứ ai có quyền exec pod cũng xem đc secret (maintainer) -> dùng Vault
		- if not Vault: xxx
	+ Gitlab-CI:
		+ save value of Vault
		+ cần xác thực (user, pass) đến Vault rồi mới pull value về được.
		-> dùng gitlab-secret
	+ Jenkins: define secret trong credential
		
- Security:
	+ Quy trình use, save credential, phân quyền, quản lý ntn:
		- credential save on Vault, chia 2 nửa, ops 1 nửa, sec 1 nửa
		- khai báo secret vào helm/manifest, path là url trên vault, đã gồm 2 nửa trên kia
	+ QT1:
		- Cluster: 	dùng RBAC giới hạn quyền của user, cho phép user/group có quyền j với secret/pro/deployment
		- k8s:		cũng cần phân quyền pod, ..., ko phải ai cũng có thể xem secret hay exec pod đc
		
	
	+ Secrets Store CSI Driver: kết hợp vs Dev + RBAC để phân quyền cho api k8s
- Migrate DB:
	+ 
	+ 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Ubuntu Alias
- Temporarily alias:	alias alias_name='aliased_command --options'	-> 	unalias alias_name
- Permanent alias:		alias alias_name='aliased_command --options'
	+ save to system file: /.bashrc	or	/.alias
	+ save user file:	/.alias need add script to /.bashrc					-> source /.bashrc OR . /bashrc: kích hoạt alias ngay
		if [ -e $HOME/.alias ]; then [ -n "$PS1" ] && . $HOME/.alias; fi
- alias: xem alisas [permanent  + temporarily]
// alias in Linux
alias ai='sudo apt-get install'
alias ar='sudo apt-get remove'
alias au='sudo apt-get update'
alias aug='sudo apt-get upgrade

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias du='du -h'			// du -sh path		du -h -d 1 path
alias df='df -h'
alias l.='ls -d .* --color=auto'
alias ls='ls -F --color=auto'
alias cl='clear && ls'		#Xóa màn hình và hiển thị file, thư mục con

alias e='exit'
alias s='sudo'
alias nnb='nano ~/.bashrc'  #Sửa file alias
alias rlb='. ~/.bashrc'		#Load lại file alias
alias h='history'

// alias in git:			git config --get-regexp alias		// check alias of git
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.last 'log -1 HEAD'

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

